1) Go has the benefit of hindsight, and the basics are done well: it has garbage collection, a package system, first class functions, lexical scope, a system call
interface, and immutable strings in which text is generally encoded in UTF-8. But it has comparatively few features and is unlikely to add more. For instance,
it has no implicit numeric conversions, no constructors or destructors, no operator overloading, no default parameter values, no inheritance, no generics,
no exceptions, no macros, no function annotations, and no thread-local storage. The language is mature and stable, and guarantees backwards compatibility: older
Go programs can be compiled and run with newer versions of compilers and standard libraries.

2) Package main is special. It defines a standalone executable program, not a library. Within package main the function main is also special—it’s where execution
of the program begins. Whatever main does is what the program does. Of course, main will normally call upon functions in other packages to do much of the work,
such as the function fmt.Println .

3) The import declarations must follow the package declaration. After that, a program consists of the declarations of functions, variables, constants, and
types (introduced by the keywords func, var, const and type); for the most part, the order of declarations does not matter.

Go does not require semicolons at the end of statements or declarations, except where two or more appear on the same line.

Newlines following certain tokens are converted into semicolons, so where newlines are placed matters to proper parsing of Go code. For instance, the opening
brace { of the function must be on the same line as the end of the func declaration, not on a line by itself, and in the expression x + y, a newline is
permitted after but not before the + operator.

Go takes a strong stance on code formatting. The gofmt tool rewrites code into the standard format, and the go tool’s fmt subcommand applies gofmt to all the
files in the specified package, or the ones in the current directory by default.

Gofmt is used by many editors to format code automatically as you save the file.
A related tool, goimports, additionally manages the insertion and removal of import declarations as needed. It is not part of the standard distribution but
you can obtain it with this command:
$ go get golang.org/x/tools/cmd/goimports

The os package provides functions and other values for dealing with the operating system in a platform independent fashion. Command-line arguments are
available to a program in a variable named Args that is part of the os package; thus its name any where outside the os package is os.Args .

4) For Loop :-
--------------
The for loop is the only loop statement in Go. It has a number of forms, one of which is illustrated here:
  for initialization; condition; post {
    // zero or more statements
  }

Any of these parts (initialization; condition; post) may be omitted. If there is no initialization and no post, the semicolons may also be omitted:
  // a traditional "while" loop
  for condition {
    // ...
  }

If the condition is omitted entirely in any of these forms, for example in
  // a traditional infinite loop
  for {
    // ...
  }
the loop is infinite, though loops of this form may be terminated in some other way, like a break or return statement.

Different bahaviors of for loop :
for condition => behaves like a while
for i,v := range list => ranges over a list
for i=0;i<10;i++ => C style classical for

5) There are several ways to declare a string variable, these are all equivalent:
s := ""
var s string
var s = ""
var s string = ""

Why should you prefer one form to another? The first form, a short variable declaration, is the most compact, but it may be used only within a function,
not for package level variables. The second form relies on default initialization to the zero value for strings, which is "". The third form is rarely used
except when declaring multiple variables. The fourth form is explicit about the variable's type, which is redundant when it is the same as that of the initial
value but necessary in other cases where they are not of the same type. In practice, you should generally use one of the first two forms, with explicit
initialization to say that the initial value is important and implicit initialization to say that the initial value doesn’t matter.

6) Just like for statement, parentheses are never used around the condition in an if statement, but braces are required for the body. There can be an optional
else part that is executed if the condition is false.

7) The function fmt.Printf, like printf in C and other languages, produces formatted output from a list of expressions. Its first argument is a format string
that specifies how subsequent arguments should be formatted. The format of each argument is determined by a conversion character, a letter following a percent
sign. For example, %d formats an integer operand using decimal notation, and %s expands to the value of a string operand.

Printf has over a dozen such conversions, which Go programmers call verbs. This table is far from a complete specification but illustrates many of the features
that are available:
%d         => decimal integer
%x, %o, %b => integer in hexadecimal, octal, binary
%f, %g, %e => floating-point number: 3.141593 3.141592653589793 3.141593e+00
%t         => boolean: true or false
%c         => rune (Unicode code point)
%s         => string
%q         => quoted string "abc" or rune 'c'
%v         => any value in a natural format
%T         => type of any value
%%         => literal percent sign (no operand)

Printf does not write a newline by default. By convention, formatting functions whose names end in f, such as log.Printf and fmt.Errorf, use the formatting
rules of fmt.Printf, where as those whose names end in ln follow Println.

8) A map is a reference to the data structure created by make. When a map is passed to a function, the function receives a copy of the reference, so any changes
the called function makes to the underlying dat a structure will be visible through the caller's map reference too.

9) After importing a package whose path has multiple components, like image/color, we refer to the package with a name that comes from the last component. Thus
the variable color.White belongs to the image/color package and gif.GIF belongs to image/gif.

10) Like var declarations, const declarations may appear at package level(so the names are visible throughout the package) or within a function(so the names
are visible only within that function). The value of a constant must be a number, string, or boolean.

11) A goroutine is a concurrent function execution. A channel is a communication mechanism that allows one goroutine to pass values of a specified type to
another goroutine. The function main runs in a goroutine and the go statement creates addition al goroutines.

12) When one goroutine attempts a send or receive on a channel, it blocks until another goroutine attempts the corresponding receive or send operation, at
which point the value is transferred and both goroutines proceed.

13) if err := r.ParseForm(); err != nil {
      log.Print(err)
    }
Go allows a simple statement such as a local variable declaration to precede the if condition, which is particularly useful for error handling as in this example. We could have written it as
   err := r.ParseForm()
   if err != nil {
     log.Print(err)
   }
but combining the statements is shorter and reduces the scope of the variable err, which is good practice.

14) Use the strconv.Atoi function to convert the string parameter into an integer.

15) Switch statement
    switch coinflip() {
    case "heads":
      heads++
    case "tails":
      tails++
    default:
      fmt.Println("landed on edge!")
    }

A switch does not need an operand; it can just list the cases, each of which is a boolean expression:

    func Signum(x int) int {
      switch {
      case x > 0:
        return +1
      default:
        return 0
      case x < 0:
        return -1
      }
    }
This form is called a tagless switch; it’s equivalent to switch true.

Like the for and if statements, a switch may include an optional simple statement - a short variable declaration, an increment or assignment statement, or a
function call that can be used to set a value before it is tested.

16) Statements may be labeled so that break and continue can refer to them, for instance to break out of several nested loops at once or to start the next
iteration of the outermost loop. There is even a goto statement, though it’s int ended for machine-generated code, not regular use by programmers.

17) Pointers are explicitly visible. The & operator yields the address of a variable, and the * operator retrieves the variable that the pointer refers to, but
there is no pointer arithmetic.

18) If an entity is declared within a function, it is local to that function. If declared outside of a function, however, it is visible in all files of the
package to which it belongs. The case of the first letter of a name determines its visibility across package boundaries. If the name begins with an uppercase
letter, it is exported, which means that it is visible and accessible outside of its own package and may be referred to by other parts of the program, as with
Printf in the fmt package. Package names themselves are always in lower case.

Go programmers use camel case when forming names by combining words; that is, interior capital letters are preferred over interior underscores. Thus the
standard libraries have functions with names like QuoteRuneToASCII and parseRequestLine but never quote_rune_to_ASCII or parse_request_line. The letters of
acronyms and initialisms like ASCII and HTML are always rendered in the same case, so a function might be called htmlEscape, HTMLEscape, or escapeHTML, but
not escapeHtml.

19) Declaration:
A declaration names a program entity and specifies some or all of its properties. There are four major kinds of declarations: var, const, type and func.

20) Variables:
A var declaration creates a variable of a particular type, attaches a name to it, and sets its initial value. Each declaration has the general form
    var name type = expression

21) Either the type or the = expression part may be omitted, but not both. If the type is omitted, it is determined by the initializer expression. If the
expression is omitted, the initial value is the zero value for the type, which is 0 for numbers, false for booleans, "" for strings, and nil for interfaces
and reference types (slice, pointer, map, channel, function). The zero value of an aggregate type like an array or a struct has the zero value of all of
its elements or fields.

The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there is no such thing as an uninitialized variable.
This simplifies code and often ensures sensible behavior of boundary conditions without extra work. For example,
    var s string
    fmt.Println(s) // ""

It is possible to declare and optionally initialize a set of variables in a single declaration, with a matching list of expressions. Omitting the type allows
declaration of multiple variables of different types:
    var i, j, k int                 // int, int, int
    var b, f, s = true, 2.3, "four" // bool, float64, string

22) Short Variable Declarations
Within a function, an alternate form called a short variable declaration may be used to declare and initialize local variables. It takes the form 
    name := expression
and the type of name is determined by the type of expression.

Because of their brevity and flexibility, short variable declarations are used to declare and initialize the majority of local variables. A var declaration
tends to be reserved for local variables that need an explicit type that differs from that of the initializer expression, or for when the variable will be
assigned a value later and its initial value is unimportant.
    i := 100 // an int
    var boiling float64 = 100 // a float64
    var names []string
    var err error
    var p Point

As with var declarations, multiple variables may be declared and initialized in the same short variable declaration,
    i, j := 0, 1
is same as
    var i, j = 0, 1

    i, j = j, i // swap values of i and j

23) One subtle but important point: a short variable declaration does not necessarily declare all the variables on its left-hand side. If some of them were
already declared in the same lexical block, then the short variable declaration acts like an assignment to those variables.

In the code below, the first statement declares both in and err. The second declares out but only assigns a value to the existing err variable.
    in, err := os.Open(infile)
    // ...
    out, err := os.Create(outfile)

A short variable declaration must declare at least one new variable, however, so this code will not compile:
    f, err := os.Open(infile)
    // ...
    f, err := os.Create(outfile) // compile error: no new variables

The fix is to use an ordinary assignment for the second statement.

A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block
are ignored.

24) If a variable is declared var x int, the expression &x ("address of x") yields a pointer to an integer variable, that is, a value of type *int, which is
pronounced "pointer to int". If this value is called p, we say "p points to x", or equivalently "p contains the address of x". The variable to which p points
is written *p. The expression *p yields the value of that variable, an int, but since *p denotes a variable, it may also appear on the lefthand side of an
assignment, in which case the assignment updates the variable.

x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"

25) The zero value for a pointer of any type is nil . The test p != nil is true if p points to a variable. Pointers are comparable; two pointers are equal if
and only if the y point to the same variable or both are nil.
    var x, y int
    fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"

26) The new function:
Another way to create a variable is to use the built-in function new. The expression new(T) creates an unnamed variable of type T, initializes it to the zero
value of T, and returns its address, which is a value of type *T.

p := new(int)    // p, of type *int, points to an unnamed int variable
fmt.Println(*p)  // "0"
*p = 2           // sets the unnamed int to 2
fmt.Println(*p)  // "2"

A variable created with new is no different from an ordinary local variable whose address is taken, except that there's no need to invent (and declare) a dummy
name, and we can use new(T) in an expression. Thus new is only a syntactic convenience, not a fundamental notion:
the two newInt functions below have identical behaviors.
  func newInt() *int {
    return new(int)
  }

  func newInt() *int {
    var dummy int
    return &dummy
  }

Since new is a predeclared function, not a keyword, it's possible to redefine the name for something else within a function, for example:
  func delta(old, new int) int { return new - old }
Of course, within delta, the built-in new function is unavailable.

27) Packages in Go serve the same purposes as libraries or modules in other languages, supporting modularity, encapsulation, separate compilation, and reuse.
The source code for a package resides in one or more .go files, usually in a directory whose name ends with the import path.

28) Packages also let us hide information by controlling which names are visible outside the package, or exported. In Go, a simple rule governs which
identifiers are exported and which are not: exported identifiers start with an upper-case letter.

29) Package initialization:
Any file may contain any number of functions whose declaration is just
  func init() { /* ... */ }
Such init functions can’t be called or referenced, but otherwise they are normal functions. Within each file, init functions are automatically executed when
the program starts, in the order in which they are declared.

1) Go's concurrency support is one of its strongest features. Goroutines are like threads, but use far less memory and require much less code to implement.
Channels are typed memory queues that let you send messages between goroutines. This facilitates a programming model where you send data between goroutines,
rather than letting the goroutines fight to use the same data.

2) GOROUTINES
Goroutines are functions that run concurrently with other goroutines, including the entry point of your program. In other languages, you would use threads to
accomplish the same thing, but in Go, many goroutines execute on a single thread.
For example, if you write a web server and you want to handle different web requests simultaneously, you would have to write a lot of extra code to use threads
in C or Java, but Go's net/http library has concurrency built in using goroutines.
Each inbound request automatically processes on it's own goroutine. Goroutines use less memory than threads and the Go runtime will automatically schedule the
execution of goroutines from a configurable pool of threads. This makes your application much more efficient with significantly less development effort.

3) CHANNELS
Channels are typed memory queues that act as a pipeline to enable safe data communication between goroutines. When used correctly, channels help you to
avoid problems typically seen in programming languages that allow shared memory access.
The hardest part of concurrency is ensuring that your data is not unexpectedly modified by concurrently running processes, threads, or goroutines. When multiple
threads change the same data without locks or synchronization, heartache always follows. When you have global variables and shared memory, you are required to
use complicated mutexes or locks to prevent unsynchronized changes to the same variables.
Channels help to solve this problem by providing a pattern that makes data safe from concurrent modification. Channels help to enforce the pattern that only one
goroutine should modify the data at any time. You can see an example of this flow in Figure 1.3, where channels are used to send data between several running
goroutines. Imagine an application where many different processes need to know about or modify data sequentially. Using goroutines and channels, you can model
this process safely.


Reference:
1) https://www.whitesmith.co/blog/why-i-started-to-use-golang-more-than-python-or-ruby/
