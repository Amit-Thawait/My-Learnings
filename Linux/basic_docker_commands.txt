Basic docker commands :
-----------------------
docker

docker -v

docker info

docker images

docker ps

docker ps -a

docker run -i -t ubuntu:xenial /bin/bash

docker inspect ubuntu:xenial

docker restart compassionate_bhabha

docker attach compassionate_bhabha

docker rename compassionate_bhabha my_new_container_name
docker rename <container_id> <new_container_name>

docker run -i -t -d ubuntu:xenial /bin/bash
docker run -itd ubuntu:xenial /bin/bash

docker inspect <container_name>
docker inspect compassionate_bhabha
docker inspect compassionate_bhabha | grep IP

docker stop <container_name>
docker stop compassionate_bhabha

For exiting without stopping the container type: ctrl+p+q

----------------------------------------------------------------------------------
Inside docker container if "apt-get update" is not working then follow these steps
nm-tool | grep DNS
then go to /etc/default/docker file
DOCKER_OPTS="--dns <ip1> --dns <ip2>"

OR
nmcli dev list | grep IP4.DNS

The CentOS equivalent is the /etc/sysconfig/docker
-----------------------------------------------------------------------------------

docker search <image_name>
docker search training/sinatra

docker commit -m "commit message" -a "<User name>" <docker-container-name> <new_image_name>
docker commit -m "Installed SSH and created test user" -a "Amit Thawait" flamboyant_edison amitthawait/ubuntu-sshd:v1

mkdir build
cd build
vim Dockerfile
-----------
# This is a custom ubuntu image with SSH installed
FROM ubuntu:latest
MAINTAINER Amit Thawait <amit17thawait@gmail.com>
RUN apt-get update
RUN apt-get install -y telnet openssh-server
-----------

With RUN command inside a Dockerfile, whatever command is passed to it, its result becomes part of the base image.
For ex: For the above docker file, telnet and openssh-server become part of the base image after an image is built from it.

docker build -t="new_image_name" <location of docker_file>
docker build -t="amitthawait/ubuntu-sshdonly:v2" .
OR
docker build -t="amitthawait/ubuntu-sshdonly:v2" < /location/Dockerfile
OR
docker build -t "amitthawait/ubuntu-sshdonly:v2" .

The advantage of using a Dockerfile is that it creates an instance of docker container using the base image and then deletes it upon exiting whereas in the case of
commiting a changes to docker container it doesn't removes the instance there by taking up disk space.

docker logs <container_name>
docker logs naughty_brown

docker exec <container_name> <command>
docker exec naughty_brown /bin/cat /etc/profile

For docker exec command : the container in which exec command is fired should be running

docker run ubuntu:xenial echo "Hello from this container"
The above command just runs the echo command and exits. Even if you restart the above container it will just run the echo command again and will exit.

If you want to just create a container and not run it
docker create -it --name="my_container" ubuntu:latest /bin/bash
you can start it using
docker start my_container

docker pull nginx:latest

docker run -d -p 80 nginx:latest

docker run -d -p 8080:80 nginx:latest
This command binds host port 8080 to container port 80

0.0.0.0 means all interfaces including host IP, localhost etc.

You can also pass specfic host IP as well like 127.0.0.1
docker run -d -p 127.0.0.1:8081:80 nginx:latest

You can also bind only tcp or udp port
docker run -d -p 127.0.0.1:8081:80/udp nginx:latest

docker run -itd docker.io/centos:6 /bin/bash
Pull a docker image and running it in daemon mode in 1 go

docker rm <container_name>
docker rm jolly_pare

Naming a container
docker run -it --name=test_ssh -p 8022:22 docker.io/centos:6 /bin/bash

docker rmi <image_id>
docker rmi 0ef2e08ed3fa

With rmi you can also delete a docker image by name
docker rmi <image_name>
docker rmi centos/java_8:v1

docker exec -u 0 -it <container_name> /bin/bash
-u 0 signifies user with id 0 which is actually root user
docker exec -u 0 -it condescending_albattani /bin/bash

Difference between CMD and RUN
RUN command is executed while building the base image,
whereas CMD command is added as configuration for the base image and is executed when the image is instantiated.
Command stated using CMD directive will not be executed if the container is asked to do something else like connecting to /bin/bash while instanting.

ENTRYPOINT command is similar to CMD command except it will always be executed the container is instantiated.
ALso, if something else is asked to run while instanting lets say /bin/bash, then it will be simply ignored and the command mentioned in ENTRYPOINT will be run.

A command can be run on a container having ENTRYPOINT using "docker exec" command
docker exec apacheweb1 /bin/cat /var/www/html/index.html

-P(High port mapping scheme): expose and remap automatically any ports that are exposed within the container. Port need to exposed from container using EXPOSE command.
docker run -d --name apacheweb3 -P centos7/apache:v2

To mount a volume in the container
docker run -it --name voltest1 -v /mydata centos:latest /bin/bash
The above /mydata can be found out at _data dir inside volumes in /var/lib/docker/volumes/<hash>/_data which can seen using docker inspect <container_name> command.

docker run -it --name voltest2 -v /home/user/builds/my_host_data_dir:/mydata centos:latest /bin/bash
This command mount a local file system outside docker file system to /mydata dir.

docker network ls

docker network ls --no-trunc

docker network inspect bridge

All the docker commands are also available as man pages. Just add hyphen for multi word command. For ex: man page for docker run command
man docker-run
man docker-network-create

Create a network
docker network create --subnet 10.1.0.0/24 --gateway 10.1.0.1 mybridge01

docker network inspect mybridge01

docker network rm mybridge01

Assigning a IP range to containers
docker network create --subnet 10.1.0.0/16 --gateway 10.1.0.1 --ip-range=10.1.4.0/24 --driver=bridge --label=host4network bridge04
docker network ls
ifconfig
docker network inspect bridge04

docker run -it --name nettest1 --net bridge04 centos:latest /bin/bash
yum update
yum install -y nettools
ifconfig

Assigning a IP to a container
docker run -it --name nettest2 --net bridge04 --ip 10.1.4.100 centos:latest /bin/bash

docker top <container_name>
docker top apacheweb1

docker stats <container_name>
This commands shows the live stats related to CPU, memory etc means realtime view of the resources the container is using.

List only container ids
docker ps -a -q

docker ps -a -q | wc -l

docker events
Attaches to docker daemon and waits for any event to happen and the lists it

See man docker-events

docker events --filter event=attach

docker events --filter event=attach --filter event=die --filter event=stop

For local backup & restoring of base images :
Saving a base image
docker save centos:latest > centos.latest.tar
OR
docker save --output centos.latest.tar centos:latest

To check the content of tar file
tar tvf centos.latest.tar

To further compress the tar file
gzip centos.latest.tar

To load the container from compressed file
docker load < centos.latest.tar
OR
docker load --input centos.latest.tar
docker load --input centos.latest.tar.gz

History of image
docker history centos7:apache/v2
# for detailed output
docker history --no-trunc centos7:apache/v2

Tagging a image
docker tag <image_name> <new_image_name>
docker tag <image_id> <new_image_name>

docker tag centos:latest centos/7:v1

Pushing a image to docker hub
First create a repository in hub.docker.com, then create a tag with same name in localhost then push it after login.
docker tag centos7/apache:v2 amitthawait/mycentosv3
docker login
docker push amit17thawait/mycentosv3
docker logout
