Go has the benefit of hindsight, and the basics are done well: it has garbage collection, a package system, first class functions, lexical scope, a system call
interface, and immutable strings in which text is generally encoded in UTF-8. But it has comparatively few features and is unlikely to add more. For instance,
it has no implicit numeric conversions, no constructors or destructors, no operator overloading, no default parameter values, no inheritance, no generics,
no exceptions, no macros, no function annotations, and no thread-local storage. The language is mature and stable, and guarantees backwards compatibility: older
Go programs can be compiled and run with newer versions of compilers and standard libraries.

Package main is special. It defines a standalone executable program, not a library. Within package main the function main is also special—it’s where execution
of the program begins. Whatever main does is what the program does. Of course, main will normally call upon functions in other packages to do much of the work,
such as the function fmt.Println .

1) Go's concurrency support is one of its strongest features. Goroutines are like threads, but use far less memory and require much less code to implement.
Channels are typed memory queues that let you send messages between goroutines. This facilitates a programming model where you send data between goroutines,
rather than letting the goroutines fight to use the same data.

2) GOROUTINES
Goroutines are functions that run concurrently with other goroutines, including the entry point of your program. In other languages, you would use threads to
accomplish the same thing, but in Go, many goroutines execute on a single thread.
For example, if you write a web server and you want to handle different web requests simultaneously, you would have to write a lot of extra code to use threads
in C or Java, but Go's net/http library has concurrency built in using goroutines.
Each inbound request automatically processes on it's own goroutine. Goroutines use less memory than threads and the Go runtime will automatically schedule the
execution of goroutines from a configurable pool of threads. This makes your application much more efficient with significantly less development effort.

3) CHANNELS
Channels are typed memory queues that act as a pipeline to enable safe data communication between goroutines. When used correctly, channels help you to
avoid problems typically seen in programming languages that allow shared memory access.
The hardest part of concurrency is ensuring that your data is not unexpectedly modified by concurrently running processes, threads, or goroutines. When multiple
threads change the same data without locks or synchronization, heartache always follows. When you have global variables and shared memory, you are required to
use complicated mutexes or locks to prevent unsynchronized changes to the same variables.
Channels help to solve this problem by providing a pattern that makes data safe from concurrent modification. Channels help to enforce the pattern that only one
goroutine should modify the data at any time. You can see an example of this flow in Figure 1.3, where channels are used to send data between several running
goroutines. Imagine an application where many different processes need to know about or modify data sequentially. Using goroutines and channels, you can model
this process safely.
