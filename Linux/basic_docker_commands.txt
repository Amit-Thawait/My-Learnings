Basic docker commands :
-----------------------
docker

docker -v

docker info

docker images

docker ps

docker ps -a

docker run -i -t ubuntu:xenial /bin/bash

docker inspect ubuntu:xenial

docker restart compassionate_bhabha

docker attach compassionate_bhabha

docker run -i -t -d ubuntu:xenial /bin/bash
docker run -itd ubuntu:xenial /bin/bash

docker inspect <container_name>
docker inspect compassionate_bhabha
docker inspect compassionate_bhabha | grep IP

docker stop <container_name>
docker stop compassionate_bhabha

For exiting without stopping the container type: ctrl+p+q

----------------------------------------------------------------------------------
Inside docker container if "apt-get update" is not working then follow these steps
nm-tool | grep DNS
then go to /etc/default/docker file
DOCKER_OPTS="--dns <ip1> --dns <ip2>"

OR
nmcli dev list | grep IP4.DNS

The CentOS equivalent is the /etc/sysconfig/docker
-----------------------------------------------------------------------------------

docker search <image_name>
docker search training/sinatra

docker commit -m "commit message" -a "<User name>" <docker-container-name> <new_image_name>
docker commit -m "Installed SSH and created test user" -a "Amit Thawait" flamboyant_edison amitthawait/ubuntu-sshd:v1

mkdir build
cd build
vim Dockerfile
-----------
# This is a custom ubuntu image with SSH installed
FROM ubuntu:latest
MAINTAINER Amit Thawait <amit17thawait@gmail.com>
RUN apt-get update
RUN apt-get install -y telnet openssh-server
-----------

With RUN command inside a Dockerfile, whatever command is passed to it, its result becomes part of the base image.
For ex: For the above docker file, telnet and openssh-server become part of the base image after an image is built from it.

docker build -t="new_image_name" <location of docker_file>
docker build -t="amitthawait/ubuntu-sshdonly:v2" .
OR
docker build -t="amitthawait/ubuntu-sshdonly:v2" < /location/Dockerfile
OR
docker build -t "amitthawait/ubuntu-sshdonly:v2" .

The advantage of using a Dockerfile is that it creates an instance of docker container using the base image and then deletes it upon exiting whereas in the case of
commiting a changes to docker container it doesn't removes the instance there by taking up disk space.

docker logs <container_name>
docker logs naughty_brown

docker exec <container_name> <command>
docker exec naughty_brown /bin/cat /etc/profile

For docker exec command : the container in which exec command is fired should be running

docker run ubuntu:xenial echo "Hello from this container"
The above command just runs the echo command and exits. Even if you restart the above container it will just run the echo command again and will exit.

docker pull nginx:latest

docker run -d -p 8080:80 nginx:latest

docker run -itd docker.io/centos:6 /bin/bash
Pull a docker image and running it in daemon mode in 1 go

docker rm <container_name>
docker rm jolly_pare

Naming a container
docker run -it --name=test_ssh -p 8022:22 docker.io/centos:6 /bin/bash

docker rmi <image_id>
docker rmi 0ef2e08ed3fa

With rmi you can also delete a docker image by name
docker rmi <image_name>
docker rmi centos/java_8:v1

docker exec -u 0 -it <container_name> /bin/bash
-u 0 signifies user with id 0 which is actually root user
docker exec -u 0 -it condescending_albattani /bin/bash

Difference between CMD and RUN
RUN command is executed while building the base image,
whereas CMD command is added as configuration for the base image and is executed when the image is instantiated.
Command stated using CMD directive will not be executed if the container is asked to do something else like connecting to /bin/bash while instanting.

ENTRYPOINT command is similar to CMD command except it will always be executed the container is instantiated.
ALso, if something else is asked to run while instanting lets say /bin/bash, then it will be simply ignored and the command mentioned in ENTRYPOINT will be run.

A command can be run on a container having ENTRYPOINT using "docker exec" command
docker exec apacheweb1 /bin/cat /var/www/html/index.html

-P(High port mapping scheme): expose and remap automatically any ports that are exposed within the container. Port need to exposed from container using EXPOSE command.
docker run -d --name apacheweb3 -P centos7/apache:v2

To mount a volume in the container
docker run -it --name voltest1 -v /mydata centos:latest /bin/bash
The above /mydata can be found out at _data dir inside volumes in /var/lib/docker/volumes/<hash>/_data which can seen using docker inspect <container_name> command.

docker run -it --name voltest2 -v /home/user/builds/my_host_data_dir:/mydata centos:latest /bin/bash
This command mount a local file system outside docker file system to /mydata dir.

docker network ls

docker network ls --no-trunc

docker network inspect bridge

All the docker commands are also available as man pages. Just add hyphen for multi word command. For ex: man page for docker run command
man docker-run
man docker-network-create

Create a network
docker network create --subnet 10.1.0.0/24 --gateway 10.1.0.1 mybridge01

docker network inspect mybridge01

docker network rm mybridge01
