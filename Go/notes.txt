1) Go has the benefit of hindsight, and the basics are done well: it has garbage collection, a package system, first class functions, lexical scope, a system call
interface, and immutable strings in which text is generally encoded in UTF-8. But it has comparatively few features and is unlikely to add more. For instance,
it has no implicit numeric conversions, no constructors or destructors, no operator overloading, no default parameter values, no inheritance, no generics,
no exceptions, no macros, no function annotations, and no thread-local storage. The language is mature and stable, and guarantees backwards compatibility: older
Go programs can be compiled and run with newer versions of compilers and standard libraries.

2) Package main is special. It defines a standalone executable program, not a library. Within package main the function main is also special—it’s where execution
of the program begins. Whatever main does is what the program does. Of course, main will normally call upon functions in other packages to do much of the work,
such as the function fmt.Println .

3) The import declarations must follow the package declaration. After that, a program consists of the declarations of functions, variables, constants, and
types (introduced by the keywords func, var, const and type); for the most part, the order of declarations does not matter.

Go does not require semicolons at the end of statements or declarations, except where two or more appear on the same line.

Newlines following certain tokens are converted into semicolons, so where newlines are placed matters to proper parsing of Go code. For instance, the opening
brace { of the function must be on the same line as the end of the func declaration, not on a line by itself, and in the expression x + y, a newline is
permitted after but not before the + operator.

Go takes a strong stance on code formatting. The gofmt tool rewrites code into the standard format, and the go tool’s fmt subcommand applies gofmt to all the
files in the specified package, or the ones in the current directory by default.

Gofmt is used by many editors to format code automatically as you save the file.
A related tool, goimports, additionally manages the insertion and removal of import declarations as needed. It is not part of the standard distribution but
you can obtain it with this command:
$ go get golang.org/x/tools/cmd/goimports

The os package provides functions and other values for dealing with the operating system in a platform independent fashion. Command-line arguments are
available to a program in a variable named Args that is part of the os package; thus its name any where outside the os package is os.Args .

4) For Loop :-
--------------
The for loop is the only loop statement in Go. It has a number of forms, one of which is illustrated here:
  for initialization; condition; post {
    // zero or more statements
  }

Any of these parts (initialization; condition; post) may be omitted. If there is no initialization and no post, the semicolons may also be omitted:
  // a traditional "while" loop
  for condition {
    // ...
  }

If the condition is omitted entirely in any of these forms, for example in
  // a traditional infinite loop
  for {
    // ...
  }
the loop is infinite, though loops of this form may be terminated in some other way, like a break or return statement.

Different bahaviors of for loop :
for condition => behaves like a while
for i,v := range list => ranges over a list
for i=0;i<10;i++ => C style classical for

5) There are several ways to declare a string variable, these are all equivalent:
s := ""
var s string
var s = ""
var s string = ""

Why should you prefer one form to another? The first form, a short variable declaration, is the most compact, but it may be used only within a function,
not for package level variables. The second form relies on default initialization to the zero value for strings, which is "". The third form is rarely used
except when declaring multiple variables. The fourth form is explicit about the variable's type, which is redundant when it is the same as that of the initial
value but necessary in other cases where they are not of the same type. In practice, you should generally use one of the first two forms, with explicit
initialization to say that the initial value is important and implicit initialization to say that the initial value doesn’t matter.

6) Just like for statement, parentheses are never used around the condition in an if statement, but braces are required for the body. There can be an optional
else part that is executed if the condition is false.

7) The function fmt.Printf, like printf in C and other languages, produces formatted output from a list of expressions. Its first argument is a format string
that specifies how subsequent arguments should be formatted. The format of each argument is determined by a conversion character, a letter following a percent
sign. For example, %d formats an integer operand using decimal notation, and %s expands to the value of a string operand.

Printf has over a dozen such conversions, which Go programmers call verbs. This table is far from a complete specification but illustrates many of the features
that are available:
%d         => decimal integer
%x, %o, %b => integer in hexadecimal, octal, binary
%f, %g, %e => floating-point number: 3.141593 3.141592653589793 3.141593e+00
%t         => boolean: true or false
%c         => rune (Unicode code point) (The type rune is an synonym for int32 and conventionally indicates that a value is a Unicode code point)
%s         => string
%q         => quoted string "abc" or rune 'c'
%v         => any value in a natural format
%T         => type of any value
%%         => literal percent sign (no operand)

Printf does not write a newline by default. By convention, formatting functions whose names end in f, such as log.Printf and fmt.Errorf, use the formatting
rules of fmt.Printf, where as those whose names end in ln follow Println.

8) A map is a reference to the data structure created by make. When a map is passed to a function, the function receives a copy of the reference, so any changes
the called function makes to the underlying dat a structure will be visible through the caller's map reference too.

9) After importing a package whose path has multiple components, like image/color, we refer to the package with a name that comes from the last component. Thus
the variable color.White belongs to the image/color package and gif.GIF belongs to image/gif.

10) Like var declarations, const declarations may appear at package level(so the names are visible throughout the package) or within a function(so the names
are visible only within that function). The value of a constant must be a number, string, or boolean.

11) A goroutine is a concurrent function execution. A channel is a communication mechanism that allows one goroutine to pass values of a specified type to
another goroutine. The function main runs in a goroutine and the go statement creates addition al goroutines.

12) When one goroutine attempts a send or receive on a channel, it blocks until another goroutine attempts the corresponding receive or send operation, at
which point the value is transferred and both goroutines proceed.

13) if err := r.ParseForm(); err != nil {
      log.Print(err)
    }
Go allows a simple statement such as a local variable declaration to precede the if condition, which is particularly useful for error handling as in this example.
We could have written it as
   err := r.ParseForm()
   if err != nil {
     log.Print(err)
   }
but combining the statements is shorter and reduces the scope of the variable err, which is good practice.

14) Use the strconv.Atoi function to convert the string parameter into an integer.

15) Switch statement
    switch coinflip() {
    case "heads":
      heads++
    case "tails":
      tails++
    default:
      fmt.Println("landed on edge!")
    }

A switch does not need an operand; it can just list the cases, each of which is a boolean expression:

    func Signum(x int) int {
      switch {
      case x > 0:
        return +1
      default:
        return 0
      case x < 0:
        return -1
      }
    }
This form is called a tagless switch; it’s equivalent to switch true.

Like the for and if statements, a switch may include an optional simple statement - a short variable declaration, an increment or assignment statement, or a
function call that can be used to set a value before it is tested.

16) Statements may be labeled so that break and continue can refer to them, for instance to break out of several nested loops at once or to start the next
iteration of the outermost loop. There is even a goto statement, though it’s int ended for machine-generated code, not regular use by programmers.

17) Pointers are explicitly visible. The & operator yields the address of a variable, and the * operator retrieves the variable that the pointer refers to, but
there is no pointer arithmetic.

18) If an entity is declared within a function, it is local to that function. If declared outside of a function, however, it is visible in all files of the
package to which it belongs. The case of the first letter of a name determines its visibility across package boundaries. If the name begins with an uppercase
letter, it is exported, which means that it is visible and accessible outside of its own package and may be referred to by other parts of the program, as with
Printf in the fmt package. Package names themselves are always in lower case.

Go programmers use camel case when forming names by combining words; that is, interior capital letters are preferred over interior underscores. Thus the
standard libraries have functions with names like QuoteRuneToASCII and parseRequestLine but never quote_rune_to_ASCII or parse_request_line. The letters of
acronyms and initialisms like ASCII and HTML are always rendered in the same case, so a function might be called htmlEscape, HTMLEscape, or escapeHTML, but
not escapeHtml.

19) Declaration:
A declaration names a program entity and specifies some or all of its properties. There are four major kinds of declarations: var, const, type and func.

20) Variables:
A var declaration creates a variable of a particular type, attaches a name to it, and sets its initial value. Each declaration has the general form
    var name type = expression

21) Either the type or the = expression part may be omitted, but not both. If the type is omitted, it is determined by the initializer expression. If the
expression is omitted, the initial value is the zero value for the type, which is 0 for numbers, false for booleans, "" for strings, and nil for interfaces
and reference types (slice, pointer, map, channel, function). The zero value of an aggregate type like an array or a struct has the zero value of all of
its elements or fields.

The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there is no such thing as an uninitialized variable.
This simplifies code and often ensures sensible behavior of boundary conditions without extra work. For example,
    var s string
    fmt.Println(s) // ""

It is possible to declare and optionally initialize a set of variables in a single declaration, with a matching list of expressions. Omitting the type allows
declaration of multiple variables of different types:
    var i, j, k int                 // int, int, int
    var b, f, s = true, 2.3, "four" // bool, float64, string

22) Short Variable Declarations
Within a function, an alternate form called a short variable declaration may be used to declare and initialize local variables. It takes the form 
    name := expression
and the type of name is determined by the type of expression.

Because of their brevity and flexibility, short variable declarations are used to declare and initialize the majority of local variables. A var declaration
tends to be reserved for local variables that need an explicit type that differs from that of the initializer expression, or for when the variable will be
assigned a value later and its initial value is unimportant.
    i := 100 // an int
    var boiling float64 = 100 // a float64
    var names []string
    var err error
    var p Point

As with var declarations, multiple variables may be declared and initialized in the same short variable declaration,
    i, j := 0, 1
is same as
    var i, j = 0, 1

    i, j = j, i // swap values of i and j

23) One subtle but important point: a short variable declaration does not necessarily declare all the variables on its left-hand side. If some of them were
already declared in the same lexical block, then the short variable declaration acts like an assignment to those variables.

In the code below, the first statement declares both in and err. The second declares out but only assigns a value to the existing err variable.
    in, err := os.Open(infile)
    // ...
    out, err := os.Create(outfile)

A short variable declaration must declare at least one new variable, however, so this code will not compile:
    f, err := os.Open(infile)
    // ...
    f, err := os.Create(outfile) // compile error: no new variables

The fix is to use an ordinary assignment for the second statement.

A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block
are ignored.

24) If a variable is declared var x int, the expression &x ("address of x") yields a pointer to an integer variable, that is, a value of type *int, which is
pronounced "pointer to int". If this value is called p, we say "p points to x", or equivalently "p contains the address of x". The variable to which p points
is written *p. The expression *p yields the value of that variable, an int, but since *p denotes a variable, it may also appear on the lefthand side of an
assignment, in which case the assignment updates the variable.

x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"

25) The zero value for a pointer of any type is nil . The test p != nil is true if p points to a variable. Pointers are comparable; two pointers are equal if
and only if the y point to the same variable or both are nil.
    var x, y int
    fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"

26) The new function:
Another way to create a variable is to use the built-in function new. The expression new(T) creates an unnamed variable of type T, initializes it to the zero
value of T, and returns its address, which is a value of type *T.

p := new(int)    // p, of type *int, points to an unnamed int variable
fmt.Println(*p)  // "0"
*p = 2           // sets the unnamed int to 2
fmt.Println(*p)  // "2"

A variable created with new is no different from an ordinary local variable whose address is taken, except that there's no need to invent (and declare) a dummy
name, and we can use new(T) in an expression. Thus new is only a syntactic convenience, not a fundamental notion:
the two newInt functions below have identical behaviors.
  func newInt() *int {
    return new(int)
  }

  func newInt() *int {
    var dummy int
    return &dummy
  }

Since new is a predeclared function, not a keyword, it's possible to redefine the name for something else within a function, for example:
  func delta(old, new int) int { return new - old }
Of course, within delta, the built-in new function is unavailable.

27) Packages in Go serve the same purposes as libraries or modules in other languages, supporting modularity, encapsulation, separate compilation, and reuse.
The source code for a package resides in one or more .go files, usually in a directory whose name ends with the import path.

28) Packages also let us hide information by controlling which names are visible outside the package, or exported. In Go, a simple rule governs which
identifiers are exported and which are not: exported identifiers start with an upper-case letter.

29) Package initialization:
Any file may contain any number of functions whose declaration is just
  func init() { /* ... */ }
Such init functions can’t be called or referenced, but otherwise they are normal functions. Within each file, init functions are automatically executed when
the program starts, in the order in which they are declared.

30) Within a function, lexical blocks may be nested to arbitrary depth, so one local declaration can shadow another. Most blocks are created by control-flow
constructs like if statements and for loops.

Not all lexical blocks correspond to explicit brace-delimited sequences of statements; some are merely implied. The for loop above creates two lexical blocks:
the explicit block for the loop body, and an implicit block that additionally encloses the variables declared by the initialization clause, such as i. The scope
of a variable declared in the implicit block is the condition, post-statement (i++), and body of the for statement.

The example below also has three variables named x, each declared in a different block : one in the function body, one in the for statement’s block, and one in
the loop body—but only two of the blocks are explicit:
    func main() {
        x := "hello"
        for _, x := range x {
            x := x + 'A' - 'a'
            fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
        }
    }

Like for loops, if statements and switch statements also create implicit blocks in addition to their body blocks. The code in the following if - else chain
shows the scope of x and y :
    if x := f(); x == 0 {
        fmt.Println(x)
    } else if y := g(x); x == y {
        fmt.Println(x, y)
    } else {
        fmt.Println(x, y)
    }
    fmt.Println(x, y) // compile error: x and y are not visible here

The second if statement is nested within the first, so variables declared within the first statement's initializer are visible within the second. Similar rules
apply to each case of a switch statement: there is a block for the condition and a block for each case body.

31) Go's types fall into four categories: basic types, aggregate types, reference types, and interface types.
Basic types     : numbers, strings, and booleans
Aggregate types : arrays and structs form more complicated data types by combining values of several simpler ones.
Reference types : pointers, slices, maps, functions and channels.

32) The type rune is an synonym for int32 and conventionally indicates that a value is a Unicode code point. The two names may be used interchangeably. Similarly,
the type byte is an synonym for uint8, and emphasizes that the value is a piece of raw data rather than a small numeric quantity.

33) Signed numbers are represented in 2's-complement for m, in which the high-order bit is reserved for the sign of the number and the range of values of an
n-bit number is from -(2^(n-1)) to (2^(n-1))-1. Unsigned integers use the full range of bits for non-negative values and thus have the range 0 to 2^(n−1).
For instance, the range of int8 is −128 to 127, where as the range of uint8 is 0 to 255.

34) o := 0666
    fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
    x := int64(0xdeadbeef)
    fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)  // Output: 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
Note the use of two fmt tricks. Usually a Printf format string containing multiple % verbs would require the same number of extra operands, but the [1] "adverbs"
after % tell Printf to use the first operand over and over again. Second, the # adverb for %o or %x or %X tells Printf to emit a 0 or 0x or 0X prefix respectively.

35) Runes(unicode code points) are printed with %c , or with %q if quoting is desired.
    ascii := 'a'
    fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"

36) Go provides two sizes of floating-point numbers, float32 and float64.
Values of these numeric types range from tiny to huge. The limits of floating-point values can be found in the math package. The constant math.MaxFloat32,
the largest float32 , is about 3.4e38, and math.MaxFloat64 is about 1.8e308. The smallest positive values are near 1.4e-45 and 4.9e-324, respectively.

A float32 provides approximately six decimal digits of precision, where as a float64 provides about 15 digits; float64 should be preferred for most purposes
because float32 computations accumulate error rapidly unless one is quite careful, and the smallest positive integer that cannot be exactly represented as a
float32 is not large:
    var f float32 = 16777216 // 1 << 24
    fmt.Println(f == f+1) // "true"!

Very small or very large numbers are better written in scientific notation, with the letter e or E preceding the decimal exponent:
    const Avogadro = 6.02214129e23
    const Planck   = 6.62606957e-34

37) Floating-point values are conveniently printed with Printf's %g verb, which chooses the most compact representation that has adequate precision, but for
tables of data, the %e (exponent) or %f (no exponent) forms may be more appropriate. All three verbs allow field width and numeric precision to be controlled.
    for x := 0; x < 8; x++ {
        fmt.Printf("x = %d e A = %8.3f\n", x, math.Exp(float64(x)))
    }
The code above prints the powers of e with three decimal digits of precision, aligned in an eight-character field.

38) The function math.IsNaN tests whether its argument is a not-a-number value, and math.NaN returns such a value but any comparison with NaN always yields false.

39) Complex Numbers:
    var x complex128 = complex(1, 2) // 1+2i
    OR
    x := 1 + 2i

The math/cmplx package provides library functions for working with complex numbers, such as the complex square root and exponentiation functions.
    fmt.Println(cmplx.Sqrt(-1)) // "(0+1i)"

40) Strings:
A string is an immutable sequence of bytes. The built-in len function returns the number of bytes (not runes) in a string, and the index operation s[i] retrieves
the i-th byte of string s, where 0 ≤ i < len(s)
    s := "hello, world"
    fmt.Println(len(s))     // "12"
    fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')

The i-th byte of a string is not necessarily the i-th character of a string, because the UTF-8 encoding of a non-ASCII code point requires two or more bytes.

The substring operation s[i:j] yields a new string consisting of the bytes of the original string starting at index i and continuing up to, but not including,
the byte at index j.
    fmt.Println(s[0:5]) // "hello"
Either or both of the i and j operands may be omitted, in which case the default values of 0 (the start of the string) and len(s) (its end) are assumed, respectively.
    fmt.Println(s[:5])  // "hello"
    fmt.Println(s[7:])  // "world"
    fmt.Println(s[:])   // "hello, world"

The + operator makes a new string by concatenating two strings:
    fmt.Println("goodbye" + s[5:]) // "goodbye, world"

41) String comparison is done byte by byte. String values are immutable: the byte sequence contained in a string value can never be changed, though of course we
can assign a new value to a string variable. += operator does not modify the string, creates a new string. For a string s :
    s[0] = 'L' // compile error: cannot assign to s[0]

42) Immutability me ans that it is safe for two copies of a string to share the same underlying memory, making it cheap to copy strings of any length. Similarly,
a string s and a substring like s[7:] may safely share the same data, so the substring operation is also cheap. No new memory is allocated in either case.

43) Within a double-quoted string literal, escape sequences that begin with a backslash \ can be used to insert arbitrary byte values into the string. One set
of escapes handles ASCII control codes like newline, carriage return, and tab:
    \a "alert" or bell
    \b backspace
    \f form feed
    \n newline
    \r carriage return
    \t tab
    \v vertical tab
    \' single quote (only in the rune literal '\'' )
    \" double quote (only within "..." literals)
    \\ backslash

Arbitrary bytes can also be included in literal strings using hexadecimal or octal escapes. A hexadecimal escape is written \xhh, with exactly two hexadecimal
digits h (in upper or lower case). An octal escape is written \ooo with exactly three octal digits o (0 through 7) not exceeding \377. Both denote a single byte
with the specified value.

44) A raw string literal is written `...`, using backquotes instead of double quotes. Within a raw string literal, no escape sequences are processed; the contents
are taken literally, including backslashes and newlines, so a raw string literal may spread over several lines in the program source. The only processing is that
carriage returns are deleted so that the value of the string is the same on all platforms, including those that conventionally put carriage returns in text files.

Raw string literals are a convenient way to write regular expressions, which tend to have lots of backslashes. They are also useful for HTML templates, JSON
literals, command usage messages, and the like, which often extend over multiple lines.
Ex:
const GoUsage = `Go is a tool for managing Go source code.
Usage:
    go command [arguments]
...`

45) If a slice of runes is converted to a string, it produces the concatenation of the UTF-8 encodings of each rune.
Converting an integer value to a string interprets the integer as a rune value, and yields the UTF-8 representation of that rune:
    fmt.Println(string(65)) // "A", not "65"

46) A string contains an array of bytes that, once created, is immutable. By contrast, the elements of a byte slice can be freely modified.
Strings can be converted to byte slices and back again:
    s := "abc"
    b := []byte(s)
    s2 := string(b)

Conceptually, the []byte(s) conversion allocates a new byte array holding a copy of the bytes of s, and yields a slice that references the entirety of that array.
An optimizing compiler may be able to avoid the allocation and copying in some cases, but in general copying is required to ensure that the bytes of s remain
unchanged even if those of b are subsequently modified. The conversion from byte slice back to string with string(b) also makes a copy, to ensure immutability
of the resulting string s2.

47) To convert an integer to a string, one option is to use fmt.Sprintf, another is to use the function strconv.Itoa ("integer to ASCII"):
    x := 123
    y := fmt.Sprintf("%d", x)
    fmt.Println(y, strconv.Itoa(x)) // "123 123"

FormatInt and FormatUint can be used to format numbers in a different base:
    fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"

The fmt.Printf verbs %b, %d, %u and %x are often more convenient than Format functions, especially if we want to include additional information besides the number:
    s := fmt.Sprintf("x=%b", x) // "x=1111011"

To parse a string representing an integer, use the strconv functions Atoi or ParseInt or ParseUint for unsigned integers:
    x, err := strconv.Atoi("123")             // x is an int
    y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
The third argument of ParseInt gives the size of the integer type that the result must fit into; for example, 16 implies int16, and the special value of 0
implies int. In any case, the type of the result y is always int64, which you can then convert to a smaller type.

48) Constants :
Constants are expressions whose value is known to the compiler and whose evaluation is guaranteed to occur at compile time, not at runtime. The underlying
type of every constant is a basic type: boolean, string or number.
Many computations on constants can be completely evaluated at compile time, reducing the work necessary at runtime and enabling other compiler optimizations.

A constant declaration may specify a type as well as a value, but in the absence of an explicit type, the type is inferred from the expression on the right-hand side.

47) Wh en a sequence of con stants is declare d as a gro up, the rig ht-hand side expression may be
omit ted for all but the firs t of the gro up, imp l ying that the pre vious expression and its typ e
should be used again. For example:
const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"

48) The Constant Generator iota :
A const declaration may use the constant generator iota, which is used to create a sequence of related values without spelling out each one explicitly. In a
const declaration, the value of iota begins at zero and increments by one for each item in the sequence.

Here's an example from the time package, which defines named constants of type Weekday for the days of the week, starting with zero for Sunday. Types of this
kind are often called enumerations, or enums for short.

    type Weekday int
    const (
        Sunday Weekday = iota
        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Saturday
    )
This declares Sunday to be 0, Monday to be 1, and so on.

49) Arrays :
An array is a fixed-length sequence of zero or more elements of a particular type. Because of their fixed length, arrays are rarely used directly in Go.
Slices, which can grow and shrink, are much more versatile.

In an array literal, if an ellipsis "..." appears in place of the length, the array length is determined by the number of initializers. The definition of q can
be simplified to
    q := [...]int{1, 2, 3}
    fmt.Printf("%T\n", q) // "[3]int"

The size of an array is part of its type, so [3]int and [4]int are different types.
    q := [3]int{1, 2, 3}
    q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int

Example :
    package main

    import "fmt"

    func main() {
        months := [...]string{1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun", 7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"}
        fmt.Printf("Type of months is : %T\n", months) // Type of months is : [13]string
        fmt.Println(months[0])                         // Empty string
        fmt.Println(months)                            // [ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec]
        fmt.Println(months[3])                         // Mar

        days := [...]string{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}
        fmt.Printf("Type of days is : %T\n", days)     // Type of days is : [7]string
        fmt.Println(days)                              // [Monday Tuesday Wednesday Thursday Friday Saturday Sunday]
        fmt.Println(days[5])                           // Saturday

        type Currency int
        const (
                USD Currency = iota
                EUR
                GBP
                RMB
        )
        symbol := [...]string{USD: "$", EUR: "E", GBP: " ! ", RMB: "R"}
        fmt.Println(RMB, symbol[RMB])                   // 3 R
    }

50) If an array's element type is comparable then the array type is comparable too, so we may directly compare two arrays of that type using the == operator,
which reports whether all corresponding elements are equal.
    a := [2]int{1, 2}
    b := [...]int{1, 2}
    c := [2]int{1, 3}
    fmt.Println(a == b, a == c, b == c) // "true false false"

    d := [3]int{1, 2}
    fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int

51) When a function is called, a copy of each argument value is assigned to the corresponding parameter variable, so the function receives a copy, not the
original. Passing large arrays in this way can be inefficient, and any changes that the function makes to array elements affe ct only the copy, not the
original. In this regard, Go treats arrays like any other type, but this behavior is different from languages that implicitly pass arrays by reference.

Using a pointer to an array is efficient and allows the called function to mutate the caller's variable, but arrays are still inherently inflexible because
of their fixed size.

52) Slices
Slices represent variable-length sequences whose elements all have the same type. A slice type is written []T, where the elements have type T; it looks like
an array type without a size.

Arrays and slices are intimately connected. A slice is a lightweight dat a structure that gives access to a subsequence (or perhaps all) of the elements of
an array, which is known as the slice's un derlying array. A slice has three components: a pointer, a length, and a capacity. The pointer points to the first
element of the array that is reachable through the slice, which is not necessarily the array's first element. The length is the number of slice elements; it
can't exceed the capacity, which is usually the number of elements between the start of the slice and the end of the underlying array. The built-in functions
len and cap return those values.

Multiple slices can share the same underlying array and may refer to overlapping parts of that array.

53) Example:
    package main

    import "fmt"

    func main() {
        months := [...]string{1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun", 7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"}
        Q2 := months[4:7]
        summer := months[6:9]
        fmt.Println(Q2)             // ["Apr" "May" "Jun"]
        fmt.Println(summer)         // ["Jun" "Jul" "Aug"]
        endlessSummer := summer[:5] // extend a slice (within capacity)
        fmt.Println(endlessSummer)  // "[Jun Jul Aug Sep Oct]"
    }

54) Unlike arrays, slices are not comparable, so we cannot use == to test whether two slices contain the same elements. The standard library provides the
highly optimized bytes.Equal function for comparing two slices of bytes ([]byte), but for other types of slice, we must do the comparison ourselves.

    func equal(x, y []string) bool {
        if len(x) != len(y) {
            return false
        }
        for i := range x {
            if x[i] != y[i] {
                return false
            }
        }
        return true
    }

The only legal slice comparison is against nil, as in
    if summer == nil { /* ... */ }

The zero value of a slice type is nil. A nil slice has no underlying array. The nil slice has length and capacity zero, but there are also non-nil slices
of length and capacity zero, such as []int{} or make([]int, 3)[3:]. As with any type that can have nil values, the nil value of a particular slice type can
be written using a conversion expression such as []int(nil).

    var s []int    // len(s) == 0, s == nil
    s = nil        // len(s) == 0, s == nil
    s = []int(nil) // len(s) == 0, s == nil
    s = []int{}    // len(s) == 0, s != nil

So, if you need to test whether a slice is empty, use len(s) == 0, not s == nil. Other than comparing equal to nil, a nil slice behaves like any other
zero-length slice; reverse(nil) is perfectly safe.

55) The built-in function make creates a slice of a specified element type, length, and capacity. The capacity argument may be omitted, in which case the
capacity equals the length.
    make([]T, len)
    make([]T, len, cap) // same as make([]T, cap)[:len]
Under the hood, make creates an unnamed array variable and returns a slice of it; the array is accessible only through the returned slice. In the first form,
the slice is a view of the entire array. In the second, the slice is a view of only the array's first len elements, but its capacity includes the entire array.
The additional elements are set aside for future growth.

56) To copy slice from one to another 'copy' function is used :
    copy(z, x) // z is destination, x is source

57) Usually we don't know whether a given call to append will cause a reallocation, so we can't assume that the original slice refers to the same array as the
resulting slice, nor that it refers to a different one. Similarly, we must not assume that operations on elements of the old slice will (or will not) be
reflected in the new slice.
As a result, it's usual to assign the result of a call to append to the same slice variable whose value we passed to append:
    runes = append(runes, r)

58) Updating the slice variable is required not just when calling append, but for any function that may change the length or capacity of a slice or make it
refer to a different underlying array. To use slices correctly, it's important to bear in mind that although the elements of the underlying array are indirect,
the slice's pointer, length, and capacity are not.

59) The built-in append lets us add more than one new element, or even a whole slice of them.
    var x []int
    x = append(x, 1)
    x = append(x, 2, 3)
    x = append(x, 4, 5, 6)
    x = append(x, x...) // append the slice x
    fmt.Println(x)      // [1 2 3 4 5 6 1 2 3 4 5 6]

The ellipsis "..." in the declarat ion of appendInt makes the function variadic: it accepts any number of final arguments.

60) Map:
In Go, a map is a reference to a hash table, and a map type is written map[K]V, where K and V are the types of its keys and values. All of the keys in a
given map are of the same type, and all of the values are of the same type, but the keys need not be of the same type as the values. The key type K must be
comparable using ==, so that the map can test whether a given key is equal to one already within it. Though floating-point numbers are comparable, it's a bad
idea to compare floats for equality, especially bad if NaN is a possible value. There are no restrictions on the value type V.

61) The built-in function make can be used to create a map:

    ages := make(map[string]int) // mapping from strings to ints

We can also use a map literal to create a new map populated with some initial key/value pairs:

    ages := map[string]int{
        "alice": 31,
        "charlie": 34,
    }

This is equivalent to

    ages := make(map[string]int)
    ages["alice"] = 31
    ages["charlie"] = 34

so an alternative expression for a new empty map is map[string]int{} .

Map elements are accessed through the usual subscript notation:

    ages["alice"] = 32
    fmt.Println(ages["alice"]) // "32"

and removed with the built-in function delete :

    delete(ages, "alice") // remove element ages["alice"]

All of these operations are safe even if the element isn't in the map. A map lookup using a key that isn't present returns the zero value for its type, so,
for instance, the following works even when "bob" is not yet a key in the map because the value of ages["bob"] will be 0.
    ages["bob"] = ages["bob"] + 1 // happy birthday!

Address of map elements (&ages["bob"] // compile error: cannot take address of map element) cannot be accessed because growing a map might cause rehashing
of existing elements into new storage locations, thus potentially invalidating the address.

To enumerate all the key/value pairs in the map, we use a range -based for loop.

62) The zero value for a map type is nil, that is, a reference to no hash table at all.
    var ages map[string]int
    fmt.Println(ages == nil)    // "true"
    fmt.Println(len(ages) == 0) // "true

Most operations on maps, including lookup, delete, len and range loops, are safe to perform on a nil map reference, since it behaves like an empty map. But
storing to a nil map causes a panic:
    ages["carol"] = 21 // panic: assignment to entry in nil map
You must allocate the map before you can store into it.

63) When you need to know whether the element was really there or not. For example, if the element type is numeric, you might have to distinguish between
a non existent element and an element that happens to have the value zero, using a test like this:
    age, ok := ages["bob"]
    if !ok { /* "bob" is not a key in this map; age == 0. */ }

You'll often see these two statements combined, like this:
    if age, ok := ages["bob"]; !ok { /* ... */ }
the second is a boolean that reports whether the element was present.

64) Just like slices, maps cannot be compared to each other; the only legal comparison is with nil.

65) Structs:
A struct is an aggregate data type that groups together zero or more named values of arbitrary types as a single entity. Each value is called a field. The
classic example of a struct from data processing is the employee record, whose fields are a unique ID, the employee's name, address, date of birth, position,
salary, manager, and the like. All of these fields are collected into a single entity that can be copied as a unit, passed to functions and returned by them,
stored in arrays, and soon.

These two statements declare a struct type called Employee and a variable called john that is an instance of an Employee :

    type Employee
        ID        int
        Name      string
        Address   string
        DoB       time.Time
        Position  string
        Salary    int
        ManagerID int
    }

    var john Employee

It is accessed using dot not ation like john.Name or take its address and access it through a pointer:

    john.Salary -= 5000
    position := &john.Position
    *position = "Senior " + *position

If all the fields of a struct are comparable, the struct itself is comparable.

66) Embeded type example :
    w = Wheel{Circle{Point{8, 8}, 5}, 20}
    w = Wheel{
        Circle: Circle{
            Point: Point{X: 8, Y: 8},
            Radius: 5,
        },
        Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
    }
    fmt.Printf("%#v\n", w)
    // Output: Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}

    w.X = 42
    fmt.Printf("%#v\n", w)
    // Output: Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}

The # adverb causes Printf's %v verb to display values in a form similar to Go syntax. For struct values, this form includes the name of each field.

67) Every function call must provide an argument for each parameter, in the order in which the parameters were declared. Go has no concept of default
parameter values, nor any way to specify arguments by name, so the names of parameters and results don't matter to the caller except as documentation.

Arguments are passed by value, so the function receives a copy of each argument; modifications to the copy do not affect the caller. However, if the
argument contains some kind of reference, like a pointer, slice, map, function, or channel, then the caller may be affected by any modifications the
function makes to variables in directly referred to by the argument.

You may occasionally encounter a function declaration without a body, indicating that the function is implemented in a language other than Go. Such a
declaration defines the function signature.

    package math
    func Sin(x float64) float64 // implemented in assembly language

68) The golang.org/x/... repositories hold packages designed and maintained by the Go team for applications such as net working, internationalized text
processing, mobile platforms, image manipulation, cryptography, and developer tools. These packages are not in the standard library because they're still
under development or because they're rarely needed by the majority of Go programmers.

69) Go's garbage collector recycles unused memory, but do not assume it will release unused operating system resources like open files and network connections.
They should be closed explicitly.

70) Errors:
A function for which failure is an expected behavior returns an additional result, conventionally the last one. If the failure has only one possible cause,
the result is a boolean, usually called ok, as in this example of a cache lookup that always succeeds unless there was no entry for that key :

    value, ok := cache.Lookup(key)
    if !ok {
        // ...cache[key] does not exist...
    }

More often, and especially for I/O, the failure may have a variety of causes for which the caller will need an explanation. In such cases, the type of the
additional result is error.

71) Go's approach sets it apart from many other languages in which failures are reported using exceptions, not ordinary values. Although Go does have an
exception mechanism of sorts, it is used only for reporting truly unexpected errors that indicate a bug, not the routine errors that a robust program should
be built to expect.

The reason for this design is that exceptions tend to entangle the description of an error with the control flow required to handle it, often leading to an
undesirable outcome: routine errors are reported to the end user in the form of an incomprehensible stack trace, full of information about the structure of
the program but lacking intelligible context about what went wrong.

72) log.Fatalf("Site is down: %v\n", err). log.Fatalf prefixes the time and date to the error message. All log functions app end a newline if one is not
already present.

73) Error handling in Go has a particular rhythm. After checking an error, failure is usually dealt with before success. If failure causes the function to
return, the logic for success is not indented within an else block but follows at the outer level.

74) Function Value:
Functions are first-class values in Go: like other values, function values have types, and they may be assigned to variables or passed to or returned from
functions. A function value may be called like any other function.

    func square(n int) int     { return n * n }
    func negative(n int) int   { return -n }
    func product(m, n int) int { return m * n }

    f := square
    fmt.Println(f(3)) // "9"

    f = negative
    fmt.Println(f(3)) // "-3"
    fmt.Printf("%T\n", f) // "func(int) int"

    f = product // compile error: can't assign f(int, int) int to f(int) int

Function values may be compared with nil, but they are not comparable, so they may not be compared against each other or used as keys in a map.

Function values let us parameterize our functions over not just data, but behavior too. The standard libraries contain many examples. For instance,
strings.Map applies a function to each character of a string, joining the results to make another string.

    func add1(r rune) rune { return r + 1 }

    fmt.Println(strings.Map(add1, "HAL-9000")) // "IBM.:111"
    fmt.Println(strings.Map(add1, "VMS"))   // "WNT"
    fmt.Println(strings.Map(add1, "Admix")) // "Benjy"

75) Anonymous Function
Named functions can be declared only at the package level, but we can use a function literal to denote a function value within any expression. A function
literal is written like a function declaration, but without a name following the func keyword. It is an expression, and its value is called an anonymous
function.

    strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")

More importantly, functions defined in this way have access to the entire lexical environment, so the inner function can refer to variables from the
enclosing function.
Refer Page 135.

76) Function values are not just code but can have state. The anonymous inner function can access and update the local variables of the enclosing function.
These hidden variable references are why we classify functions as reference types and why function values are not comparable. Function values like these
are implemented using a technique called closures, and Go programmers often use this term for function values.

77) Caveat: Capturing Iteration Variables
Consider a program that must create a set of directories and later remove them. We can use a slice of function values to hold the clean-up operations.
(For brevity, we have omitted all error handling in this example.)

    var rmdirs []func()
    for _, d := range tempDirs() {
        dir := d  // NOTE: necessary!
        os.MkdirAll(dir, 0755) // creates parent directories too
        rmdirs = append(rmdirs, func() {
            os.RemoveAll(dir)
        })
    }

    // ...do some work...
    for _, rmdir := range rmdirs {
        rmdir() // clean up
    }

You may be wondering why we assigned the loop variable d to a new local variable dir within the loop body, instead of just naming the loop variable dir as 
in this subtly incorrect variant:

    var rmdirs []func()
    for _, dir := range tempDirs() {
        os.MkdirAll(dir, 0755)
        rmdirs = append(rmdirs, func() {
            os.RemoveAll(dir) // NOTE: incorrect!
        })
    }

The reason is a consequence of the scope rules for loop variables. In the program immediately above, the for loop introduces a new lexical block in which
the variable dir is declared. All function values created by this loop "capture" and share the same variable—an addressable storage location, not its value
at that particular moment. The value of dir is updated in successive iterations, so by the time the cleanup functions are called, the dir variable has been
updated several times by the now-completed for loop. Thus dir holds the value from the final iteration, and consequently all calls to os.RemoveAll will
attempt to remove the same directory.

78) A variadic function is one that can be called with varying numbers of arguments. The most familiar examples are fmt.Printf and its variants. Printf
requires one fixed argument at the beginning, then accepts any number of subsequent arguments.
To declare a variadic function, the type of the final parameter is preceded by an ellipsis, "...", which indicates that the function may be called with any
number of arguments of this type.

    func sum(vals ...int) int {
        total := 0
        for _, val := range vals {
            total += val
        }
        return total
    }

Within the body of the function, the type of vals is an []int slice.

Implicitly, the caller allocates an array, copies the arguments into it, and passes a slice of the entire array to the function. The last call above thus
behaves the same as the call below, which shows how to invoke a variadic function when the arguments are already in a slice: place an ellipsis after the
final argument.

    values := []int{1, 2, 3, 4}
    fmt.Println(sum(values...)) // "10"

The suffix f is a widely followed naming convention for variadic functions.
The interface{} type means that this function can accept any values at all for its final arguments.

79) defer statement :
As functions grow more complex and have to handle more errors, such duplication of clean-up logic may become a maintenance problem. Let's see how Go's
defer mechanism makes things simpler.

A defer statement is an ordinary function or method call prefixed by the keyword defer. The function and argument expressions are evaluated when the
statement is executed, but the actual call is deferred until the function that contains the defer statement has finished, whether normally, by executing
a return statement or falling off the end, or abnormally, by panicking. Any number of calls may be deferred; they are executed in the reverse of the order
in which they were deferred.

A defer statement is often used with paired operations like open and close, connect and disconnect, or lock and unlock to ensure that resources are released
in all cases, no matter how complex the control flow. The right place for a defer statement that releases a resource is immediately after the resource has
been successfully acquired.

80) When not to defer :
    func fetch(url string) (filename string, n int64, err error) {
        resp, err := http.Get(url)
        if err != nil {
            return "", 0, err
        }
        defer resp.Body.Close()

        local := path.Base(resp.Request.URL.Path)
        if local == "/" {
            local = "index.html"
        }
        f, err := os.Create(local)
        if err != nil {
            return "", 0, err
        }
        n, err = io.Copy(f, resp.Body)
        // Close file, but prefer error from Copy, if any.
        if closeErr := f.Close(); err == nil {
            err = closeErr
        }
        return local, n, err
    }

The deferred call to resp.Body.Close should be familiar by now. It's tempting to use a second deferred call, to f.Close, to close the local file, but this
would be subtly wrong because os.Create opens a file for writing, creating it as needed. On many file systems, notably NFS, write errors are not reported
immediately but may be postpone d until the file is closed. Failure to check the result of the close operation could cause serious data loss to go unnoticed.
However, if both io.Copy and f.Close fail, we should prefer to report the error from io.Copy since it occurred first and is more likely to tell us the root
cause.

81) Panic :
Go's type system catches many mistakes at compile time, but others, like an out-of-bounds array access or nil pointer dereference, require checks at run time.
When the Go runtime detects these mistakes, it panics.

During a typical panic, normal execution stops, all deferred function calls in that goroutine are executed, and the program crashes with a log message. This
log message includes the panic value, which is usually an error message of some sort, and, for each goroutine, a stack trace showing the stack of function
calls that were active at the time of the panic.

Not all panics come from the runtime. The built-in panic function may be called directly ; it accepts any value as an argument. A panic is often the best
thing to do when some "impossible" situation happens, for instance, execution reaches a case that logically can't happen.

This kind of panic is unnecessary

    if x == nil {
        panic("x is nil") // unnecessary!
    }

Although Go's panic mechanism resembles exceptions in other languages, the situations in which panic is used are quite different. Since a panic causes the
program to crash, it is generally used for grave errors, such as a logical inconsistency in the program; diligent programmers consider any crash to be proof
of a bug in their code. In a robust program, "expected" errors, the kind that arise from incorrect input, misconfiguration, or failing I/O, should be handled
gracefully; they are best dealt with using error values.

82) Method :
In Go an object is simply a value or variable that has methods, and a method is a function associated with a particular type. An object-oriented program is
one that uses methods to express the properties and operations of each data structure so that clients need not access the object's representation directly.

Method Declaration :
A method is declared with a variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attaches
the function to the type of that parameter.
Ex:
    package geometry

    import "math"

    type Point struct{ X, Y float64 }

    // traditional function
    func Distance(p, q Point) float64 {
        return math.Hypot(q.X-p.X, q.Y-p.Y)
    }

    // same thing, but as a method of the Point type
    func (p Point) Distance(q Point) float64 {
        return math.Hypot(q.X-p.X, q.Y-p.Y)
    }

The extra parameter p is called the method's receiver, a legacy from early object-oriented languages that described calling a method as "sending a message
to an object."

In Go, we don't use a special name like this or self for the receiver; we choose receiver names just as we would for any other parameter. Since the
receivername will be frequently used, it's a good idea to choose something short and to be consistent across methods. A common choice is the first letter
of the type name, like p for Point.

    p := Point{1, 2}
    q := Point{4, 6}
    fmt.Println(Distance(p, q)) // "5", function call
    fmt.Println(p.Distance(q)) // "5", method call

There's no conflict between the two declarations of functions called Distance above. The first declares a package-level function called geometry.Distance .
The second declares a method of the type Point, so its name is Point.Distance.

If there a attribute X in Point p like p.X, declaring a method X on the struct type Point would be ambiguous and the compiler will reject it. 

83) Go is unlike many other object-oriented languages. It is often convenient to define additional behaviors for simple types such as numbers, strings,
slices, maps, and sometimes even functions. Methods may be declared on any named type defined in the same package, so long as its underlying type is
neither a pointer nor an interface.

84) Calling a function in Go makes a copy of each argument value, if a function needs to update a variable, or if an argument is so large that we wish to
avoid copying it, we must pass the address of the variable using a pointer.
Ex:
    func (p *Point) ScaleBy(factor float64) {
        p.X *= factor
        p.Y *= factor
    }

The name of this method is (*Point).ScaleBy . The parentheses are necessary ; without them, the expression would be parsed as *(Point.ScaleBy) .

To avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types:
    type P *int
    func (P) f() { /* ... */ } // compile error: invalid receiver type

But the language helps us to write this in a convenient way.
If the receiver p is a variable of type Point but the method requires a *Point receiver, we can use this shorthand:

    p.ScaleBy(2)

and the compiler will perform an implicit &p on the variable. This works only for variables, including struct fields like p.X and array or slice elements
like perim[0]. We cannot call a *Point method on a non-addressable Point receiver, because there's no way to obtain the address of a temporary value.

    Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal

85) If any method has a pointer receiver, you should avoid copying instances of T because doing so may violate internal invariants. For example, copying
an instance of bytes.Buffer would cause the original and the copy to alias the same underlying array of bytes. Subsequent method calls would have
unpredictable effects.

86) Composing Types by Struct Embedding:
Consider Ex:
    import "image/color"

    type Point struct{ X, Y float64 }

    type ColoredPoint struct {
        Point
        Color color.RGBA
    }

We can call methods of the embedded Point field using a receiver of type ColoredPoint, even though ColoredPoint has no declared methods:
    red := color.RGBA{255, 0, 0, 255}
    blue := color.RGBA{0, 0, 255, 255}
    var p = ColoredPoint{Point{1, 1}, red}
    var q = ColoredPoint{Point{5, 4}, blue}
    fmt.Println(p.Distance(q.Point)) // "5"
    p.ScaleBy(2)
    q.ScaleBy(2)
    fmt.Println(p.Distance(q.Point)) // "10"

The methods of Point have been promoted to ColoredPoint. In this way, embedding allows complex types with many methods to be built up by the composition
of several fields, each providing a few methods.

A ColoredPoint is not a Point, but it "has a" Point, and it has two additional methods Distance and ScaleBy promoted from Point.

87) A struct type may have more than one anonymous field. Had we declared ColoredPoint as

    type ColoredPoint struct {
        Point
        color.RGBA
    }

then a value of this type would have all the methods of Point, all the methods of RGBA, and any additional methods declared on ColoredPoint directly. When
the compiler resolves a selector such as p.ScaleBy to a method, it first looks for a directly declared method named ScaleBy, then for methods promoted once
from ColoredPoint's embedded fields, then for methods promoted twice from embedded fields within Point and RGBA, and soon. The compiler reports an error if
the selector was ambiguous because two methods were promoted from the same rank.

88) Method Values :
Usually we select and call a method in the same expression, as in p.Distance(), but it's possible to separate these two operations. The selector p.Distance
yields a method value, a function that binds a method (Point.Distance) to a specific receiver value p. This function can then be invoked without a receiver
value; it needs only the non-receiver arguments.
    p := Point{1, 2}
    q := Point{4, 6}
    distanceFromP := p.Distance    // method value
    fmt.Println(distanceFromP(q))  // "5"

89) Method Expression :
Related to the method value is the method expression. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way
using the selector syntax. A method expression, written T.f or (*T).f where T is a type, yields a function value with a regular first parameter taking the
place of the receiver, so it can be called in the usual way.
    p := Point{1, 2}
    q := Point{4, 6}

    distance := Point.Distance  // method expression
    fmt.Println(distance(p, q)) // "5"
    fmt.Printf("%T\n", distance) // "func(Point, Point) float64"

    scale := (*Point).ScaleBy
    scale(&p, 2)
    fmt.Println(p)            // "{2 4}"
    fmt.Printf("%T\n", scale) // "func(*Point, float64)"

90) Encapsulation
A variable or method of an object is said to be encapsulated if it is inaccessible to clients of the object. Encapsulation, sometimes called information
hiding, is a key aspect of object-oriented programming.
Go has only one mechanism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and
uncapitalized names are not. The same mechanism that limits access to members of a package also limits access to the fields of a struct or the methods
of a type. As a consequence, to encapsulate an object, we must make it a struct.

91) Encapsulat ion provides three benefits :
  i) because clients cannot directly modify the object's var iables, one need inspect fewer statements to understand the possible values of those variables.
 ii) hiding implementation details prevents clients from depending on things that might change, which gives the designer greater freedom to evolve the
implementation without breaking API compatibility.
iii) it prevents clients from setting an object's variables arbitrarily. Because the object's variables can be set only by functions in the same package,
the author of that package can ensure that all those functions maintain the object's internal invariants.

92) Encapsulation is not always desirable. By revealing its representation as an int64 number of nanoseconds, time.Duration lets us use all the usual
arithmetic and comparison operations with durations, and even to define constants of this type:
    const day = 24 * time.Hour
    fmt.Println(day.Seconds()) // "86400"

93) Interfaces :
Many object-oriented languages have some notion of interfaces, but what makes Go's interfaces so distinctive is that they are satisfied implicitly. In other
words, there's no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough.
This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful
for types defined in packages that you don't control.

94) All the types we've looked at so far have been concrete types. A concrete type specifies the exact representation of its values and exposes the intrinsic
operations of that representation, such as arithmetic for numbers, or indexing, append, and range for slices. A concrete type may also provide additional
behaviors through its methods. When you have a value of a concrete type, you know exactly what it is and what you can do with it.

There is another kind of type in Go called an interface type. An interface is an abstract type. It doesn't expose the representation or internal structure
of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know
nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods.

fmt.Printf, which writes the result to the standard output (a file), and fmt.Sprintf, which returns the result as a string. Both of these functions are,
in effect, wrappers around a third function, fmt.Fprintf .

95) Interface Types
An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface.

The io.Writer type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which
includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The io package defines many other useful interfaces.
A Reader represents any type from which you can read bytes, and a Closer is any value that you can close, such as a file or a network connection.

    package io

    type Reader interface {
        Read(p []byte) (n int, err error)
    }

    type Closer interface {
        Close() error
    }

Interface types can also be declared as combinations of existing ones

    type ReadWriter interface {
        Reader
        Writer
    }

    type ReadWriteCloser interface {
        Reader
        Writer
        Closer
    }

The syntax used above, which resembles struct embedding, is called embedding an interface.

96) Interface Satisfaction
A type satisfies an interface if it possesses all the methods the interface requires. For example, an *os.File satisfies io.Reader, Writer, Closer and
ReadWriter . A *bytes.Buffer satisfies Reader, Writer, and ReadWriter, but does not satisfy Closer because it does not have a Close method. As a shorthand,
Go programmers often say that a concrete type "is a" particular interface type, meaning that it satisfies the interface. For example, a *bytes.Buffer is
an io.Writer ; an *os.File is an io.ReadWriter .

var w io.Writer
w = os.Stdout          // OK: *os.File has Write method
w = new(bytes.Buffer)  // OK: *bytes.Buffer has Write method
w = time.Second        // compile error: time.Duration lacks Write method

It is legal to call a *T method on an argument of type T so long as the argument is a variable; the compiler implicitly takes its address. But this is
mere syntactic sugar : a value of type T does not possess all the methods that a *T pointer does, and as a result it might satisfy fewer interfaces.

So what does the type interface{}, which has no methods at all, tell us about the concrete types that satisfy it?
That's right: nothing. This may seem useless, but in fact the type interface{}, which is called the empty interface type, is indispensable. Because the
empty interface type places no demands on the types that satisfy it, we can assign any value to the empty interface.

    var any interface{}
    any = true
    any = 12.34
    any = "hello"
    any = map[string]int{"one": 1}
    any = new(bytes.Buffer)

1) Go's concurrency support is one of its strongest features. Goroutines are like threads, but use far less memory and require much less code to implement.
Channels are typed memory queues that let you send messages between goroutines. This facilitates a programming model where you send data between goroutines,
rather than letting the goroutines fight to use the same data.

2) GOROUTINES
Goroutines are functions that run concurrently with other goroutines, including the entry point of your program. In other languages, you would use threads to
accomplish the same thing, but in Go, many goroutines execute on a single thread.
For example, if you write a web server and you want to handle different web requests simultaneously, you would have to write a lot of extra code to use threads
in C or Java, but Go's net/http library has concurrency built in using goroutines.
Each inbound request automatically processes on it's own goroutine. Goroutines use less memory than threads and the Go runtime will automatically schedule the
execution of goroutines from a configurable pool of threads. This makes your application much more efficient with significantly less development effort.

3) CHANNELS
Channels are typed memory queues that act as a pipeline to enable safe data communication between goroutines. When used correctly, channels help you to
avoid problems typically seen in programming languages that allow shared memory access.
The hardest part of concurrency is ensuring that your data is not unexpectedly modified by concurrently running processes, threads, or goroutines. When multiple
threads change the same data without locks or synchronization, heartache always follows. When you have global variables and shared memory, you are required to
use complicated mutexes or locks to prevent unsynchronized changes to the same variables.
Channels help to solve this problem by providing a pattern that makes data safe from concurrent modification. Channels help to enforce the pattern that only one
goroutine should modify the data at any time. You can see an example of this flow in Figure 1.3, where channels are used to send data between several running
goroutines. Imagine an application where many different processes need to know about or modify data sequentially. Using goroutines and channels, you can model
this process safely.


Reference:
1) https://www.whitesmith.co/blog/why-i-started-to-use-golang-more-than-python-or-ruby/
