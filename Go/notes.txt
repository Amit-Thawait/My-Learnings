1) Go has the benefit of hindsight, and the basics are done well: it has garbage collection, a package system, first class functions, lexical scope, a system call
interface, and immutable strings in which text is generally encoded in UTF-8. But it has comparatively few features and is unlikely to add more. For instance,
it has no implicit numeric conversions, no constructors or destructors, no operator overloading, no default parameter values, no inheritance, no generics,
no exceptions, no macros, no function annotations, and no thread-local storage. The language is mature and stable, and guarantees backwards compatibility: older
Go programs can be compiled and run with newer versions of compilers and standard libraries.

2) Package main is special. It defines a standalone executable program, not a library. Within package main the function main is also special—it’s where execution
of the program begins. Whatever main does is what the program does. Of course, main will normally call upon functions in other packages to do much of the work,
such as the function fmt.Println .

3) The import declarations must follow the package declaration. After that, a program consists of the declarations of functions, variables, constants, and
types (introduced by the keywords func, var, const and type); for the most part, the order of declarations does not matter.

Go does not require semicolons at the end of statements or declarations, except where two or more appear on the same line.

Newlines following certain tokens are converted into semicolons, so where newlines are placed matters to proper parsing of Go code. For instance, the opening
brace { of the function must be on the same line as the end of the func declaration, not on a line by itself, and in the expression x + y, a newline is
permitted after but not before the + operator.

Go takes a strong stance on code formatting. The gofmt tool rewrites code into the standard format, and the go tool’s fmt subcommand applies gofmt to all the
files in the specified package, or the ones in the current directory by default.

Gofmt is used by many editors to format code automatically as you save the file.
A related tool, goimports, additionally manages the insertion and removal of import declarations as needed. It is not part of the standard distribution but
you can obtain it with this command:
$ go get golang.org/x/tools/cmd/goimports

The os package provides functions and other values for dealing with the operating system in a platform independent fashion. Command-line arguments are
available to a program in a variable named Args that is part of the os package; thus its name any where outside the os package is os.Args .

4) For Loop :-
--------------
The for loop is the only loop statement in Go. It has a number of forms, one of which is illustrated here:
  for initialization; condition; post {
    // zero or more statements
  }

Any of these parts (initialization; condition; post) may be omitted. If there is no initialization and no post, the semicolons may also be omitted:
  // a traditional "while" loop
  for condition {
    // ...
  }

If the condition is omitted entirely in any of these forms, for example in
  // a traditional infinite loop
  for {
    // ...
  }
the loop is infinite, though loops of this form may be terminated in some other way, like a break or return statement.

Different bahaviors of for loop :
for condition => behaves like a while
for i,v := range list => ranges over a list
for i=0;i<10;i++ => C style classical for

5) There are several ways to declare a string variable, these are all equivalent:
s := ""
var s string
var s = ""
var s string = ""

Why should you prefer one form to another? The first form, a short variable declaration, is the most compact, but it may be used only within a function,
not for package level variables. The second form relies on default initialization to the zero value for strings, which is "". The third form is rarely used
except when declaring multiple variables. The fourth form is explicit about the variable's type, which is redundant when it is the same as that of the initial
value but necessary in other cases where they are not of the same type. In practice, you should generally use one of the first two forms, with explicit
initialization to say that the initial value is important and implicit initialization to say that the initial value doesn’t matter.

6) Just like for statement, parentheses are never used around the condition in an if statement, but braces are required for the body. There can be an optional
else part that is executed if the condition is false.

7) The function fmt.Printf, like printf in C and other languages, produces formatted output from a list of expressions. Its first argument is a format string
that specifies how subsequent arguments should be formatted. The format of each argument is determined by a conversion character, a letter following a percent
sign. For example, %d formats an integer operand using decimal notation, and %s expands to the value of a string operand.

Printf has over a dozen such conversions, which Go programmers call verbs. This table is far from a complete specification but illustrates many of the features
that are available:
%d         => decimal integer
%x, %o, %b => integer in hexadecimal, octal, binary
%f, %g, %e => floating-point number: 3.141593 3.141592653589793 3.141593e+00
%t         => boolean: true or false
%c         => rune (Unicode code point)
%s         => string
%q         => quoted string "abc" or rune 'c'
%v         => any value in a natural format
%T         => type of any value
%%         => literal percent sign (no operand)

Printf does not write a newline by default. By convention, formatting functions whose names end in f, such as log.Printf and fmt.Errorf, use the formatting
rules of fmt.Printf, where as those whose names end in ln follow Println.

8) A map is a reference to the data structure created by make. When a map is passed to a function, the function receives a copy of the reference, so any changes
the called function makes to the underlying dat a structure will be visible through the caller's map reference too.

9) After importing a package whose path has multiple components, like image/color, we refer to the package with a name that comes from the last component. Thus
the variable color.White belongs to the image/color package and gif.GIF belongs to image/gif.

10) Like var declarations, const declarations may appear at package level(so the names are visible throughout the package) or within a function(so the names
are visible only within that function). The value of a constant must be a number, string, or boolean.

11) A goroutine is a concurrent function execution. A channel is a communication mechanism that allows one goroutine to pass values of a specified type to
another goroutine. The function main runs in a goroutine and the go statement creates addition al goroutines.

12) When one goroutine attempts a send or receive on a channel, it blocks until another goroutine attempts the corresponding receive or send operation, at
which point the value is transferred and both goroutines proceed.

13) if err := r.ParseForm(); err != nil {
      log.Print(err)
    }
Go allows a simple statement such as a local variable declaration to precede the if condition, which is particularly useful for error handling as in this example. We could have written it as
   err := r.ParseForm()
   if err != nil {
     log.Print(err)
   }
but combining the statements is shorter and reduces the scope of the variable err, which is good practice.

14) Use the strconv.Atoi function to convert the string parameter into an integer.

15) Switch statement
    switch coinflip() {
    case "heads":
      heads++
    case "tails":
      tails++
    default:
      fmt.Println("landed on edge!")
    }

A switch does not need an operand; it can just list the cases, each of which is a boolean expression:

    func Signum(x int) int {
      switch {
      case x > 0:
        return +1
      default:
        return 0
      case x < 0:
        return -1
      }
    }
This form is called a tagless switch; it’s equivalent to switch true.

Like the for and if statements, a switch may include an optional simple statement - a short variable declaration, an increment or assignment statement, or a
function call that can be used to set a value before it is tested.

16) Statements may be labeled so that break and continue can refer to them, for instance to break out of several nested loops at once or to start the next
iteration of the outermost loop. There is even a goto statement, though it’s int ended for machine-generated code, not regular use by programmers.

17) Pointers are explicitly visible. The & operator yields the address of a variable, and the * operator retrieves the variable that the pointer refers to, but
there is no pointer arithmetic.

1) Go's concurrency support is one of its strongest features. Goroutines are like threads, but use far less memory and require much less code to implement.
Channels are typed memory queues that let you send messages between goroutines. This facilitates a programming model where you send data between goroutines,
rather than letting the goroutines fight to use the same data.

2) GOROUTINES
Goroutines are functions that run concurrently with other goroutines, including the entry point of your program. In other languages, you would use threads to
accomplish the same thing, but in Go, many goroutines execute on a single thread.
For example, if you write a web server and you want to handle different web requests simultaneously, you would have to write a lot of extra code to use threads
in C or Java, but Go's net/http library has concurrency built in using goroutines.
Each inbound request automatically processes on it's own goroutine. Goroutines use less memory than threads and the Go runtime will automatically schedule the
execution of goroutines from a configurable pool of threads. This makes your application much more efficient with significantly less development effort.

3) CHANNELS
Channels are typed memory queues that act as a pipeline to enable safe data communication between goroutines. When used correctly, channels help you to
avoid problems typically seen in programming languages that allow shared memory access.
The hardest part of concurrency is ensuring that your data is not unexpectedly modified by concurrently running processes, threads, or goroutines. When multiple
threads change the same data without locks or synchronization, heartache always follows. When you have global variables and shared memory, you are required to
use complicated mutexes or locks to prevent unsynchronized changes to the same variables.
Channels help to solve this problem by providing a pattern that makes data safe from concurrent modification. Channels help to enforce the pattern that only one
goroutine should modify the data at any time. You can see an example of this flow in Figure 1.3, where channels are used to send data between several running
goroutines. Imagine an application where many different processes need to know about or modify data sequentially. Using goroutines and channels, you can model
this process safely.


Reference:
1) https://www.whitesmith.co/blog/why-i-started-to-use-golang-more-than-python-or-ruby/
