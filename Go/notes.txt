1) Go has the benefit of hindsight, and the basics are done well: it has garbage collection, a package system, first class functions, lexical scope, a system call
interface, and immutable strings in which text is generally encoded in UTF-8. But it has comparatively few features and is unlikely to add more. For instance,
it has no implicit numeric conversions, no constructors or destructors, no operator overloading, no default parameter values, no inheritance, no generics,
no exceptions, no macros, no function annotations, and no thread-local storage. The language is mature and stable, and guarantees backwards compatibility: older
Go programs can be compiled and run with newer versions of compilers and standard libraries.

2) Package main is special. It defines a standalone executable program, not a library. Within package main the function main is also special—it’s where execution
of the program begins. Whatever main does is what the program does. Of course, main will normally call upon functions in other packages to do much of the work,
such as the function fmt.Println .

3) The import declarations must follow the package declaration. After that, a program consists of the declarations of functions, variables, constants, and
types (introduced by the keywords func, var, const and type); for the most part, the order of declarations does not matter.

Go does not require semicolons at the end of statements or declarations, except where two or more appear on the same line.

Newlines following certain tokens are converted into semicolons, so where newlines are placed matters to proper parsing of Go code. For instance, the opening
brace { of the function must be on the same line as the end of the func declaration, not on a line by itself, and in the expression x + y, a newline is
permitted after but not before the + operator.

Go takes a strong stance on code formatting. The gofmt tool rewrites code into the standard format, and the go tool’s fmt subcommand applies gofmt to all the
files in the specified package, or the ones in the current directory by default.

Gofmt is used by many editors to format code automatically as you save the file.
A related tool, goimports, additionally manages the insertion and removal of import declarations as needed. It is not part of the standard distribution but
you can obtain it with this command:
$ go get golang.org/x/tools/cmd/goimports

The os package provides functions and other values for dealing with the operating system in a platform independent fashion. Command-line arguments are
available to a program in a variable named Args that is part of the os package; thus its name any where outside the os package is os.Args .

4) For Loop :-
--------------
The for loop is the only loop statement in Go. It has a number of forms, one of which is illustrated here:
  for initialization; condition; post {
    // zero or more statements
  }

Any of these parts (initialization; condition; post) may be omitted. If there is no initialization and no post, the semicolons may also be omitted:
  // a traditional "while" loop
  for condition {
    // ...
  }

If the condition is omitted entirely in any of these forms, for example in
  // a traditional infinite loop
  for {
    // ...
  }
the loop is infinite, though loops of this form may be terminated in some other way, like a break or return statement.

Different bahaviors of for loop :
for condition => behaves like a while
for i,v := range list => ranges over a list
for i=0;i<10;i++ => C style classical for

5) There are several ways to declare a string variable, these are all equivalent:
s := ""
var s string
var s = ""
var s string = ""

Why should you prefer one form to another? The first form, a short variable declaration, is the most compact, but it may be used only within a function,
not for package level variables. The second form relies on default initialization to the zero value for strings, which is "". The third form is rarely used
except when declaring multiple variables. The fourth form is explicit about the variable's type, which is redundant when it is the same as that of the initial
value but necessary in other cases where they are not of the same type. In practice, you should generally use one of the first two forms, with explicit
initialization to say that the initial value is important and implicit initialization to say that the initial value doesn’t matter.

6) Just like for statement, parentheses are never used around the condition in an if statement, but braces are required for the body. There can be an optional
else part that is executed if the condition is false.

7) The function fmt.Printf, like printf in C and other languages, produces formatted output from a list of expressions. Its first argument is a format string
that specifies how subsequent arguments should be formatted. The format of each argument is determined by a conversion character, a letter following a percent
sign. For example, %d formats an integer operand using decimal notation, and %s expands to the value of a string operand.

Printf has over a dozen such conversions, which Go programmers call verbs. This table is far from a complete specification but illustrates many of the features
that are available:
%d         => decimal integer
%x, %o, %b => integer in hexadecimal, octal, binary
%f, %g, %e => floating-point number: 3.141593 3.141592653589793 3.141593e+00
%t         => boolean: true or false
%c         => rune (Unicode code point) (The type rune is an synonym for int32 and conventionally indicates that a value is a Unicode code point)
%s         => string
%q         => quoted string "abc" or rune 'c'
%v         => any value in a natural format
%T         => type of any value
%%         => literal percent sign (no operand)

Printf does not write a newline by default. By convention, formatting functions whose names end in f, such as log.Printf and fmt.Errorf, use the formatting
rules of fmt.Printf, where as those whose names end in ln follow Println.

8) A map is a reference to the data structure created by make. When a map is passed to a function, the function receives a copy of the reference, so any changes
the called function makes to the underlying dat a structure will be visible through the caller's map reference too.

9) After importing a package whose path has multiple components, like image/color, we refer to the package with a name that comes from the last component. Thus
the variable color.White belongs to the image/color package and gif.GIF belongs to image/gif.

10) Like var declarations, const declarations may appear at package level(so the names are visible throughout the package) or within a function(so the names
are visible only within that function). The value of a constant must be a number, string, or boolean.

11) A goroutine is a concurrent function execution. A channel is a communication mechanism that allows one goroutine to pass values of a specified type to
another goroutine. The function main runs in a goroutine and the go statement creates addition al goroutines.

12) When one goroutine attempts a send or receive on a channel, it blocks until another goroutine attempts the corresponding receive or send operation, at
which point the value is transferred and both goroutines proceed.

13) if err := r.ParseForm(); err != nil {
      log.Print(err)
    }
Go allows a simple statement such as a local variable declaration to precede the if condition, which is particularly useful for error handling as in this example. We could have written it as
   err := r.ParseForm()
   if err != nil {
     log.Print(err)
   }
but combining the statements is shorter and reduces the scope of the variable err, which is good practice.

14) Use the strconv.Atoi function to convert the string parameter into an integer.

15) Switch statement
    switch coinflip() {
    case "heads":
      heads++
    case "tails":
      tails++
    default:
      fmt.Println("landed on edge!")
    }

A switch does not need an operand; it can just list the cases, each of which is a boolean expression:

    func Signum(x int) int {
      switch {
      case x > 0:
        return +1
      default:
        return 0
      case x < 0:
        return -1
      }
    }
This form is called a tagless switch; it’s equivalent to switch true.

Like the for and if statements, a switch may include an optional simple statement - a short variable declaration, an increment or assignment statement, or a
function call that can be used to set a value before it is tested.

16) Statements may be labeled so that break and continue can refer to them, for instance to break out of several nested loops at once or to start the next
iteration of the outermost loop. There is even a goto statement, though it’s int ended for machine-generated code, not regular use by programmers.

17) Pointers are explicitly visible. The & operator yields the address of a variable, and the * operator retrieves the variable that the pointer refers to, but
there is no pointer arithmetic.

18) If an entity is declared within a function, it is local to that function. If declared outside of a function, however, it is visible in all files of the
package to which it belongs. The case of the first letter of a name determines its visibility across package boundaries. If the name begins with an uppercase
letter, it is exported, which means that it is visible and accessible outside of its own package and may be referred to by other parts of the program, as with
Printf in the fmt package. Package names themselves are always in lower case.

Go programmers use camel case when forming names by combining words; that is, interior capital letters are preferred over interior underscores. Thus the
standard libraries have functions with names like QuoteRuneToASCII and parseRequestLine but never quote_rune_to_ASCII or parse_request_line. The letters of
acronyms and initialisms like ASCII and HTML are always rendered in the same case, so a function might be called htmlEscape, HTMLEscape, or escapeHTML, but
not escapeHtml.

19) Declaration:
A declaration names a program entity and specifies some or all of its properties. There are four major kinds of declarations: var, const, type and func.

20) Variables:
A var declaration creates a variable of a particular type, attaches a name to it, and sets its initial value. Each declaration has the general form
    var name type = expression

21) Either the type or the = expression part may be omitted, but not both. If the type is omitted, it is determined by the initializer expression. If the
expression is omitted, the initial value is the zero value for the type, which is 0 for numbers, false for booleans, "" for strings, and nil for interfaces
and reference types (slice, pointer, map, channel, function). The zero value of an aggregate type like an array or a struct has the zero value of all of
its elements or fields.

The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there is no such thing as an uninitialized variable.
This simplifies code and often ensures sensible behavior of boundary conditions without extra work. For example,
    var s string
    fmt.Println(s) // ""

It is possible to declare and optionally initialize a set of variables in a single declaration, with a matching list of expressions. Omitting the type allows
declaration of multiple variables of different types:
    var i, j, k int                 // int, int, int
    var b, f, s = true, 2.3, "four" // bool, float64, string

22) Short Variable Declarations
Within a function, an alternate form called a short variable declaration may be used to declare and initialize local variables. It takes the form 
    name := expression
and the type of name is determined by the type of expression.

Because of their brevity and flexibility, short variable declarations are used to declare and initialize the majority of local variables. A var declaration
tends to be reserved for local variables that need an explicit type that differs from that of the initializer expression, or for when the variable will be
assigned a value later and its initial value is unimportant.
    i := 100 // an int
    var boiling float64 = 100 // a float64
    var names []string
    var err error
    var p Point

As with var declarations, multiple variables may be declared and initialized in the same short variable declaration,
    i, j := 0, 1
is same as
    var i, j = 0, 1

    i, j = j, i // swap values of i and j

23) One subtle but important point: a short variable declaration does not necessarily declare all the variables on its left-hand side. If some of them were
already declared in the same lexical block, then the short variable declaration acts like an assignment to those variables.

In the code below, the first statement declares both in and err. The second declares out but only assigns a value to the existing err variable.
    in, err := os.Open(infile)
    // ...
    out, err := os.Create(outfile)

A short variable declaration must declare at least one new variable, however, so this code will not compile:
    f, err := os.Open(infile)
    // ...
    f, err := os.Create(outfile) // compile error: no new variables

The fix is to use an ordinary assignment for the second statement.

A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block
are ignored.

24) If a variable is declared var x int, the expression &x ("address of x") yields a pointer to an integer variable, that is, a value of type *int, which is
pronounced "pointer to int". If this value is called p, we say "p points to x", or equivalently "p contains the address of x". The variable to which p points
is written *p. The expression *p yields the value of that variable, an int, but since *p denotes a variable, it may also appear on the lefthand side of an
assignment, in which case the assignment updates the variable.

x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"

25) The zero value for a pointer of any type is nil . The test p != nil is true if p points to a variable. Pointers are comparable; two pointers are equal if
and only if the y point to the same variable or both are nil.
    var x, y int
    fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"

26) The new function:
Another way to create a variable is to use the built-in function new. The expression new(T) creates an unnamed variable of type T, initializes it to the zero
value of T, and returns its address, which is a value of type *T.

p := new(int)    // p, of type *int, points to an unnamed int variable
fmt.Println(*p)  // "0"
*p = 2           // sets the unnamed int to 2
fmt.Println(*p)  // "2"

A variable created with new is no different from an ordinary local variable whose address is taken, except that there's no need to invent (and declare) a dummy
name, and we can use new(T) in an expression. Thus new is only a syntactic convenience, not a fundamental notion:
the two newInt functions below have identical behaviors.
  func newInt() *int {
    return new(int)
  }

  func newInt() *int {
    var dummy int
    return &dummy
  }

Since new is a predeclared function, not a keyword, it's possible to redefine the name for something else within a function, for example:
  func delta(old, new int) int { return new - old }
Of course, within delta, the built-in new function is unavailable.

27) Packages in Go serve the same purposes as libraries or modules in other languages, supporting modularity, encapsulation, separate compilation, and reuse.
The source code for a package resides in one or more .go files, usually in a directory whose name ends with the import path.

28) Packages also let us hide information by controlling which names are visible outside the package, or exported. In Go, a simple rule governs which
identifiers are exported and which are not: exported identifiers start with an upper-case letter.

29) Package initialization:
Any file may contain any number of functions whose declaration is just
  func init() { /* ... */ }
Such init functions can’t be called or referenced, but otherwise they are normal functions. Within each file, init functions are automatically executed when
the program starts, in the order in which they are declared.

30) Within a function, lexical blocks may be nested to arbitrary depth, so one local declaration can shadow another. Most blocks are created by control-flow
constructs like if statements and for loops.

Not all lexical blocks correspond to explicit brace-delimited sequences of statements; some are merely implied. The for loop above creates two lexical blocks:
the explicit block for the loop body, and an implicit block that additionally encloses the variables declared by the initialization clause, such as i. The scope
of a variable declared in the implicit block is the condition, post-statement (i++), and body of the for statement.

The example below also has three variables named x, each declared in a different block : one in the function body, one in the for statement’s block, and one in
the loop body—but only two of the blocks are explicit:
    func main() {
        x := "hello"
        for _, x := range x {
            x := x + 'A' - 'a'
            fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
        }
    }

Like for loops, if statements and switch statements also create implicit blocks in addition to their body blocks. The code in the following if - else chain
shows the scope of x and y :
    if x := f(); x == 0 {
        fmt.Println(x)
    } else if y := g(x); x == y {
        fmt.Println(x, y)
    } else {
        fmt.Println(x, y)
    }
    fmt.Println(x, y) // compile error: x and y are not visible here

The second if statement is nested within the first, so variables declared within the first statement's initializer are visible within the second. Similar rules
apply to each case of a switch statement: there is a block for the condition and a block for each case body.

31) Go's types fall into four categories: basic types, aggregate types, reference types, and interface types.
Basic types     : numbers, strings, and booleans
Aggregate types : arrays and structs form more complicated data types by combining values of several simpler ones.
Reference types : pointers, slices, maps, functions and channels.

32) The type rune is an synonym for int32 and conventionally indicates that a value is a Unicode code point. The two names may be used interchangeably. Similarly,
the type byte is an synonym for uint8, and emphasizes that the value is a piece of raw data rather than a small numeric quantity.

33) Signed numbers are represented in 2's-complement for m, in which the high-order bit is reserved for the sign of the number and the range of values of an
n-bit number is from -(2^(n-1)) to (2^(n-1))-1. Unsigned integers use the full range of bits for non-negative values and thus have the range 0 to 2^(n−1).
For instance, the range of int8 is −128 to 127, where as the range of uint8 is 0 to 255.

34) o := 0666
    fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
    x := int64(0xdeadbeef)
    fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)  // Output: 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
Note the use of two fmt tricks. Usually a Printf format string containing multiple % verbs would require the same number of extra operands, but the [1] "adverbs"
after % tell Printf to use the first operand over and over again. Second, the # adverb for %o or %x or %X tells Printf to emit a 0 or 0x or 0X prefix respectively.

35) Runes(unicode code points) are printed with %c , or with %q if quoting is desired.
    ascii := 'a'
    fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"

36) Go provides two sizes of floating-point numbers, float32 and float64.
Values of these numeric types range from tiny to huge. The limits of floating-point values can be found in the math package. The constant math.MaxFloat32,
the largest float32 , is about 3.4e38, and math.MaxFloat64 is about 1.8e308. The smallest positive values are near 1.4e-45 and 4.9e-324, respectively.

A float32 provides approximately six decimal digits of precision, where as a float64 provides about 15 digits; float64 should be preferred for most purposes
because float32 computations accumulate error rapidly unless one is quite careful, and the smallest positive integer that cannot be exactly represented as a
float32 is not large:
    var f float32 = 16777216 // 1 << 24
    fmt.Println(f == f+1) // "true"!

Very small or very large numbers are better written in scientific notation, with the letter e or E preceding the decimal exponent:
    const Avogadro = 6.02214129e23
    const Planck   = 6.62606957e-34

37) Floating-point values are conveniently printed with Printf's %g verb, which chooses the most compact representation that has adequate precision, but for
tables of data, the %e (exponent) or %f (no exponent) forms may be more appropriate. All three verbs allow field width and numeric precision to be controlled.
    for x := 0; x < 8; x++ {
        fmt.Printf("x = %d e A = %8.3f\n", x, math.Exp(float64(x)))
    }
The code above prints the powers of e with three decimal digits of precision, aligned in an eight-character field.

38) The function math.IsNaN tests whether its argument is a not-a-number value, and math.NaN returns such a value but any comparison with NaN always yields false.

39) Complex Numbers:
    var x complex128 = complex(1, 2) // 1+2i
    OR
    x := 1 + 2i

The math/cmplx package provides library functions for working with complex numbers, such as the complex square root and exponentiation functions.
    fmt.Println(cmplx.Sqrt(-1)) // "(0+1i)"

40) Strings:
A string is an immutable sequence of bytes. The built-in len function returns the number of bytes (not runes) in a string, and the index operation s[i] retrieves
the i-th byte of string s, where 0 ≤ i < len(s)
    s := "hello, world"
    fmt.Println(len(s))     // "12"
    fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')

The i-th byte of a string is not necessarily the i-th character of a string, because the UTF-8 encoding of a non-ASCII code point requires two or more bytes.

The substring operation s[i:j] yields a new string consisting of the bytes of the original string starting at index i and continuing up to, but not including,
the byte at index j.
    fmt.Println(s[0:5]) // "hello"
Either or both of the i and j operands may be omitted, in which case the default values of 0 (the start of the string) and len(s) (its end) are assumed, respectively.
    fmt.Println(s[:5])  // "hello"
    fmt.Println(s[7:])  // "world"
    fmt.Println(s[:])   // "hello, world"

The + operator makes a new string by concatenating two strings:
    fmt.Println("goodbye" + s[5:]) // "goodbye, world"

41) String comparison is done byte by byte. String values are immutable: the byte sequence contained in a string value can never be changed, though of course we
can assign a new value to a string variable. += operator does not modify the string, creates a new string. For a string s :
    s[0] = 'L' // compile error: cannot assign to s[0]

42) Immutability me ans that it is safe for two copies of a string to share the same underlying memory, making it cheap to copy strings of any length. Similarly,
a string s and a substring like s[7:] may safely share the same data, so the substring operation is also cheap. No new memory is allocated in either case.

43) Within a double-quoted string literal, escape sequences that begin with a backslash \ can be used to insert arbitrary byte values into the string. One set
of escapes handles ASCII control codes like newline, carriage return, and tab:
    \a "alert" or bell
    \b backspace
    \f form feed
    \n newline
    \r carriage return
    \t tab
    \v vertical tab
    \' single quote (only in the rune literal '\'' )
    \" double quote (only within "..." literals)
    \\ backslash

Arbitrary bytes can also be included in literal strings using hexadecimal or octal escapes. A hexadecimal escape is written \xhh, with exactly two hexadecimal
digits h (in upper or lower case). An octal escape is written \ooo with exactly three octal digits o (0 through 7) not exceeding \377. Both denote a single byte
with the specified value.

44) A raw string literal is written `...`, using backquotes instead of double quotes. Within a raw string literal, no escape sequences are processed; the contents
are taken literally, including backslashes and newlines, so a raw string literal may spread over several lines in the program source. The only processing is that
carriage returns are deleted so that the value of the string is the same on all platforms, including those that conventionally put carriage returns in text files.

Raw string literals are a convenient way to write regular expressions, which tend to have lots of backslashes. They are also useful for HTML templates, JSON
literals, command usage messages, and the like, which often extend over multiple lines.
Ex:
const GoUsage = `Go is a tool for managing Go source code.
Usage:
    go command [arguments]
...`

45) If a slice of runes is converted to a string, it produces the concatenation of the UTF-8 encodings of each rune.
Converting an integer value to a string interprets the integer as a rune value, and yields the UTF-8 representation of that rune:
    fmt.Println(string(65)) // "A", not "65"

46) A string contains an array of bytes that, once created, is immutable. By contrast, the elements of a byte slice can be freely modified.
Strings can be converted to byte slices and back again:
    s := "abc"
    b := []byte(s)
    s2 := string(b)

Conceptually, the []byte(s) conversion allocates a new byte array holding a copy of the bytes of s, and yields a slice that references the entirety of that array.
An optimizing compiler may be able to avoid the allocation and copying in some cases, but in general copying is required to ensure that the bytes of s remain
unchanged even if those of b are subsequently modified. The conversion from byte slice back to string with string(b) also makes a copy, to ensure immutability
of the resulting string s2.

47) To convert an integer to a string, one option is to use fmt.Sprintf, another is to use the function strconv.Itoa ("integer to ASCII"):
    x := 123
    y := fmt.Sprintf("%d", x)
    fmt.Println(y, strconv.Itoa(x)) // "123 123"

FormatInt and FormatUint can be used to format numbers in a different base:
    fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"

The fmt.Printf verbs %b, %d, %u and %x are often more convenient than Format functions, especially if we want to include additional information besides the number:
    s := fmt.Sprintf("x=%b", x) // "x=1111011"

To parse a string representing an integer, use the strconv functions Atoi or ParseInt or ParseUint for unsigned integers:
    x, err := strconv.Atoi("123")             // x is an int
    y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
The third argument of ParseInt gives the size of the integer type that the result must fit into; for example, 16 implies int16, and the special value of 0
implies int. In any case, the type of the result y is always int64, which you can then convert to a smaller type.

48) Constants :
Constants are expressions whose value is known to the compiler and whose evaluation is guaranteed to occur at compile time, not at runtime. The underlying
type of every constant is a basic type: boolean, string or number.
Many computations on constants can be completely evaluated at compile time, reducing the work necessary at runtime and enabling other compiler optimizations.

A constant declaration may specify a type as well as a value, but in the absence of an explicit type, the type is inferred from the expression on the right-hand side.

47) Wh en a sequence of con stants is declare d as a gro up, the rig ht-hand side expression may be
omit ted for all but the firs t of the gro up, imp l ying that the pre vious expression and its typ e
should be used again. For example:
const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"

48) The Constant Generator iota :
A const declaration may use the constant generator iota, which is used to create a sequence of related values without spelling out each one explicitly. In a
const declaration, the value of iota begins at zero and increments by one for each item in the sequence.

Here's an example from the time package, which defines named constants of type Weekday for the days of the week, starting with zero for Sunday. Types of this
kind are often called enumerations, or enums for short.

    type Weekday int
    const (
        Sunday Weekday = iota
        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Saturday
    )
This declares Sunday to be 0, Monday to be 1, and so on.

49) Arrays :
An array is a fixed-length sequence of zero or more elements of a particular type. Because of their fixed length, arrays are rarely used directly in Go.
Slices, which can grow and shrink, are much more versatile.

In an array literal, if an ellipsis "..." appears in place of the length, the array length is determined by the number of initializers. The definition of q can
be simplified to
    q := [...]int{1, 2, 3}
    fmt.Printf("%T\n", q) // "[3]int"

The size of an array is part of its type, so [3]int and [4]int are different types.
    q := [3]int{1, 2, 3}
    q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int

Example :
    package main

    import "fmt"

    func main() {
        months := [...]string{1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun", 7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"}
        fmt.Printf("Type of months is : %T\n", months) // Type of months is : [13]string
        fmt.Println(months[0])                         // Empty string
        fmt.Println(months)                            // [ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec]
        fmt.Println(months[3])                         // Mar

        days := [...]string{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}
        fmt.Printf("Type of days is : %T\n", days)     // Type of days is : [7]string
        fmt.Println(days)                              // [Monday Tuesday Wednesday Thursday Friday Saturday Sunday]
        fmt.Println(days[5])                           // Saturday

        type Currency int
        const (
                USD Currency = iota
                EUR
                GBP
                RMB
        )
        symbol := [...]string{USD: "$", EUR: "E", GBP: " ! ", RMB: "R"}
        fmt.Println(RMB, symbol[RMB])                   // 3 R
    }

50) If an array's element type is comparable then the array type is comparable too, so we may directly compare two arrays of that type using the == operator,
which reports whether all corresponding elements are equal.
    a := [2]int{1, 2}
    b := [...]int{1, 2}
    c := [2]int{1, 3}
    fmt.Println(a == b, a == c, b == c) // "true false false"

    d := [3]int{1, 2}
    fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int

51) When a function is called, a copy of each argument value is assigned to the corresponding parameter variable, so the function receives a copy, not the
original. Passing large arrays in this way can be inefficient, and any changes that the function makes to array elements affe ct only the copy, not the
original. In this regard, Go treats arrays like any other type, but this behavior is different from languages that implicitly pass arrays by reference.

Using a pointer to an array is efficient and allows the called function to mutate the caller's variable, but arrays are still inherently inflexible because
of their fixed size.

52) Slices
Slices represent variable-length sequences whose elements all have the same type. A slice type is written []T, where the elements have type T; it looks like
an array type without a size.

Arrays and slices are intimately connected. A slice is a lightweight dat a structure that gives access to a subsequence (or perhaps all) of the elements of
an array, which is known as the slice's un derlying array. A slice has three components: a pointer, a length, and a capacity. The pointer points to the first
element of the array that is reachable through the slice, which is not necessarily the array's first element. The length is the number of slice elements; it
can't exceed the capacity, which is usually the number of elements between the start of the slice and the end of the underlying array. The built-in functions
len and cap return those values.

Multiple slices can share the same underlying array and may refer to overlapping parts of that array.

53) Example:
    package main

    import "fmt"

    func main() {
        months := [...]string{1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun", 7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"}
        Q2 := months[4:7]
        summer := months[6:9]
        fmt.Println(Q2)             // ["Apr" "May" "Jun"]
        fmt.Println(summer)         // ["Jun" "Jul" "Aug"]
        endlessSummer := summer[:5] // extend a slice (within capacity)
        fmt.Println(endlessSummer)  // "[Jun Jul Aug Sep Oct]"
    }

54) Unlike arrays, slices are not comparable, so we cannot use == to test whether two slices contain the same elements. The standard library provides the
highly optimized bytes.Equal function for comparing two slices of bytes ([]byte), but for other types of slice, we must do the comparison ourselves.

    func equal(x, y []string) bool {
        if len(x) != len(y) {
            return false
        }
        for i := range x {
            if x[i] != y[i] {
                return false
            }
        }
        return true
    }

The only legal slice comparison is against nil, as in
    if summer == nil { /* ... */ }

The zero value of a slice type is nil. A nil slice has no underlying array. The nil slice has length and capacity zero, but there are also non-nil slices
of length and capacity zero, such as []int{} or make([]int, 3)[3:]. As with any type that can have nil values, the nil value of a particular slice type can
be written using a conversion expression such as []int(nil).

    var s []int    // len(s) == 0, s == nil
    s = nil        // len(s) == 0, s == nil
    s = []int(nil) // len(s) == 0, s == nil
    s = []int{}    // len(s) == 0, s != nil

So, if you need to test whether a slice is empty, use len(s) == 0, not s == nil. Other than comparing equal to nil, a nil slice behaves like any other
zero-length slice; reverse(nil) is perfectly safe.

55) The built-in function make creates a slice of a specified element type, length, and capacity. The capacity argument may be omitted, in which case the capacity equals the length.
    make([]T, len)
    make([]T, len, cap) // same as make([]T, cap)[:len]
Under the hood, make creates an unnamed array variable and returns a slice of it; the array is accessible only through the returned slice. In the first form,
the slice is a view of the entire array. In the second, the slice is a view of only the array's first len elements, but its capacity includes the entire array.
The additional elements are set aside for future growth.

56) To copy slice from one to another 'copy' function is used :
    copy(z, x) // z is destination, x is source

57) Usually we don't know whether a given call to append will cause a reallocation, so we can't assume that the original slice refers to the same array as the resulting
slice, nor that it refers to a different one. Similarly, we must not assume that operations on elements of the old slice will (or will not) be reflected in the new slice.
As a result, it's usual to assign the result of a call to append to the same slice variable whose value we passed to append:
    runes = append(runes, r)

58) Updating the slice variable is required not just when calling append, but for any function that may change the length or capacity of a slice or make it refer to a
different underlying array. To use slices correctly, it's important to bear in mind that although the elements of the underlying array are indirect, the slice's pointer,
length, and capacity are not.

1) Go's concurrency support is one of its strongest features. Goroutines are like threads, but use far less memory and require much less code to implement.
Channels are typed memory queues that let you send messages between goroutines. This facilitates a programming model where you send data between goroutines,
rather than letting the goroutines fight to use the same data.

2) GOROUTINES
Goroutines are functions that run concurrently with other goroutines, including the entry point of your program. In other languages, you would use threads to
accomplish the same thing, but in Go, many goroutines execute on a single thread.
For example, if you write a web server and you want to handle different web requests simultaneously, you would have to write a lot of extra code to use threads
in C or Java, but Go's net/http library has concurrency built in using goroutines.
Each inbound request automatically processes on it's own goroutine. Goroutines use less memory than threads and the Go runtime will automatically schedule the
execution of goroutines from a configurable pool of threads. This makes your application much more efficient with significantly less development effort.

3) CHANNELS
Channels are typed memory queues that act as a pipeline to enable safe data communication between goroutines. When used correctly, channels help you to
avoid problems typically seen in programming languages that allow shared memory access.
The hardest part of concurrency is ensuring that your data is not unexpectedly modified by concurrently running processes, threads, or goroutines. When multiple
threads change the same data without locks or synchronization, heartache always follows. When you have global variables and shared memory, you are required to
use complicated mutexes or locks to prevent unsynchronized changes to the same variables.
Channels help to solve this problem by providing a pattern that makes data safe from concurrent modification. Channels help to enforce the pattern that only one
goroutine should modify the data at any time. You can see an example of this flow in Figure 1.3, where channels are used to send data between several running
goroutines. Imagine an application where many different processes need to know about or modify data sequentially. Using goroutines and channels, you can model
this process safely.


Reference:
1) https://www.whitesmith.co/blog/why-i-started-to-use-golang-more-than-python-or-ruby/
